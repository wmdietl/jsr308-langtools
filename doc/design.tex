\documentclass[10pt]{article}
\usepackage{pslatex}
\usepackage{fancyvrb}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{relsize}
\usepackage{url}
\usepackage{xspace}
\usepackage[normalem]{ulem}
\usepackage{hevea}
%HEVEA \footerfalse    % Disable hevea advertisement in footer

\title{Type Annotations Specification (JSR 308)}
\author{Michael D. Ernst \\
{\ttfamily mernst@cs.washington.edu}
%HEVEA \\ \today
}

% At least 80% of every float page must be taken up by
% floats; there will be no page with more than 20% white space.
\def\topfraction{.95}
\def\dbltopfraction{\topfraction}
\def\floatpagefraction{\topfraction}     % default .5
\def\dblfloatpagefraction{\topfraction}  % default .5
\def\textfraction{.05}

% Left and right curly braces and backslash, in tt font
\newcommand{\ttlcb}{\texttt{\char "7B}}
\newcommand{\ttrcb}{\texttt{\char "7D}}
\newcommand{\ttbs}{\texttt{\char "5C}}

\begin{document}

\def\codesize{\smaller}
%HEVEA \def\codesize{\relax}
\newcommand{\code}[1]{\ifmmode{\mbox{\codesize\ttfamily{#1}}}\else{\codesize\ttfamily #1}\fi}
\def\<#1>{\code{#1}}
\newcommand{\myurl}[1]{{\codesize\url{#1}}}
%HEVEA \def\myurl{\url}

%NOT HEVEA \makeatletter
%NOT HEVEA \newcommand{\sout}[1]{\@print{<STRIKE>}{}#1\@print{</STRIKE>}}
%NOT HEVEA \makeatother

%HEVEA \def\strut{\relax}

%BEGIN LATEX
\RecustomVerbatimEnvironment{Verbatim}{Verbatim}{fontsize=\smaller}
%END LATEX

% Add line between figure and text
\makeatletter
\def\topfigrule{\kern3\p@ \hrule \kern -3.4\p@} % the \hrule is .4pt high
\def\botfigrule{\kern-3\p@ \hrule \kern 2.6\p@} % the \hrule is .4pt high
\def\dblfigrule{\kern3\p@ \hrule \kern -3.4\p@} % the \hrule is .4pt high
\makeatother

\hyphenation{Pecht-chan-ski}

\newcommand{\jlsURL}{http://java.sun.com/docs/books/jls/third_edition/html/}
\urldef{\jlsEightEightFourURL}\url{http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.8.4}
\urldef{\jlsNineSixURL}\url{http://java.sun.com/docs/books/jls/third_edition/html/interfaces.html#9.6}
\urldef{\jlsNineSixOneThreeURL}\url{http://java.sun.com/docs/books/jls/third_edition/html/interfaces.html#9.6.1.3}
\urldef{\jlsNineSevenURL}\url{http://java.sun.com/docs/books/jls/third_edition/html/interfaces.html#9.7}
\urldef{\jlsFifteenNine}\url{http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.9}
\urldef{\jlsFifteenNineFiveOneURL}\url{http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.9.5.1}
\urldef{\jlsFifteenTwelveFourFiveURL}\url{http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5}



\maketitle

The JSR 308 webpage is \myurl{http://types.cs.washington.edu/jsr308/}.
It contains the
\ahref{http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html}{latest version}
% latest version
of this document, along
with other information such as a FAQ, the reference implementation, and
sample annotation processors.

%HEVEA This document is available in PDF format at \myurl{http://types.cs.washington.edu/jsr308/specification/java-annotation-design.pdf}.


\tableofcontents

\section{Introduction\label{intro}}

JSR 308 extends Java's annotation system~\cite{JSR175} so that
annotations may appear on nearly any use of a type.
(By contrast, Java~SE~6 permits annotations only on
declarations; JSR 308 is
backward-compatible and continues to permit those annotations.)
Such a generalization removes
% removed "arbitrary" in response to Brian Goetz comment.
limitations of Java's annotation
system, and it enables new uses of annotations.
This proposal also notes a few other possible extensions to annotations (see Section~\ref{other-annotations}).

This document specifies the \emph{syntax} of extended Java annotations, but
it makes no commitment as to their \emph{semantics}.  As with Java's
existing annotations~\cite{JSR175}, the semantics is dependent on annotation processors
(compiler plug-ins), and not every annotation is necessarily sensible in
every location where it is syntactically permitted to appear.
This proposal is compatible with existing annotations,
such as those specified in JSR 250, ``Common Annotations for the Java
Platform''~\cite{JSR250}, and proposed annotations, such as those to be
specified in JSR 305, ``Annotations for Software Defect
Detection''~\cite{JSR305}.  (For a comparison of JSR 305 and JSR 308, see Section~\ref{semantics}%
%BEGIN LATEX
, page~\pageref{semantics}%
%END LATEX
.)

This proposal does not change the compile-time, load-time, or run-time
semantics of Java.  It does not change the abilities of Java annotation
processors as defined in JSR 269~\cite{JSR269}.
% or of instrumentation agents~\cite{JSR163}.
The proposal merely makes annotations more general --- and thus more useful
for their current purposes, and also usable for new purposes that are
compatible with the original vision for annotations~\cite{JSR175}.

This document has two parts:  a short normative part and a longer
non-normative part.
The normative part specifies the changes to
the Java language syntax (Sections~\ref{syntax} and~\ref{grammar-details}),
the Java toolset (Section~\ref{mods}), and
the class file format (Section~\ref{class-file}).

The non-normative part
consists of appendices that
discuss and explain the specification or deal with logistical issues.
It motivates annotations on types by presenting one
possible use, type qualifiers
(Appendix~\ref{type-qualifiers}).
It gives examples of and further motivation for the Java
syntax changes (Appendix~\ref{syntax-discussion}) and lists tools that
must be updated to accommodate the Java and class file
modifications (Appendix~\ref{mods-discussion}).
Appendix~\ref{other-annotations} lists other possible extensions to
Java annotations, some of which are within the scope of JSR 308 (and might
be included in a future revision) and some of which are not.
The document concludes with
logistical matters relating to
incorporation in the Sun JDK (Section~\ref{logistics})
and
related work (Section~\ref{related-work}).

A JSR, or Java Specification Request, is a proposed specification for some
aspect of the Java platform --- the Java language, virtual machine,
libraries, etc.  For more details, see the Java Community Process FAQ at
\myurl{http://jcp.org/en/introduction/faq}.


A FAQ (Frequently Asked Questions) document complements this specification;
see \myurl{http://types.cs.washington.edu/jsr308/jsr308-faq.html}.



\section{Java language syntax extensions\label{syntax}}



\subsection{Source locations for annotations on types\label{type-annotation-locations}}

In Java SE 6, annotations can be written only on method parameters
and the declarations of packages, classes, methods, fields, and local variables.
JSR 308 extends Java to allow annotations on nearly any use of a type, and
on type parameter declarations.
% (whether explicit or implicit, as in the case of method receivers)
JSR 308 uses a simple prefix syntax for type annotations, with a special case
for receiver types and for constructor results.
% that is necessitated by
% non-orthogonality in the Java grammar.

\begin{enumerate}
\item
  A type annotation appears before the type, as in \code{@NonNull String}.
\item
  The annotation on a given array level
  prefixes the brackets that introduce that level.  To declare
  a non-empty array of English-language strings, write \code{@English String
    @NonEmpty []}.
  The varargs syntax \code{...} is treated analogously to array brackets
  and may also be prefixed by an annotation.
\item
  An annotation on the type of a method receiver (\code{this}) appears
  just after the parameter list and before any \code{throws} clause.
  (Each non-static method has an implicit parameter, \code{this}, which is
  called the \emph{receiver}.)
\item
  An annotation on a type parameter declaration appears before the declared
  name or wildcard.
\end{enumerate}

Section~\ref{type-annotation-syntax-examples} contains examples of the annotation syntax.


\subsection{Summary of Java language grammar changes\label{grammar-summary}}

% The original grammar appears at
% http://java.sun.com/docs/books/jls/third_edition/html/syntax.html

% The BNF for the spec does not have to be the same as the BNF for the
% implementation.  An example is that the BNF does not address the ">>" issue
% in generics, even though that's important for an implementation.

This section
% Section~\ref{grammar-summary}
summarizes the Java language grammar changes, which correspond to
the rules of Section~\ref{type-annotation-locations}.
Section~\ref{grammar-details} shows the grammar changes in detail.
Additions are \underline{underlined}.
% and deletions crossed out.


% \subsubsection{Summary\label{grammar-summary}}

\newcommand{\term}[1]{\code{#1}}         % terminal
\newcommand{\nt}[1]{\emph{#1}}           % non-terminal
\newcommand{\opt}[1]{\emph{[}#1\emph{]}} % optional (zero or one)
\newcommand{\multi}[1]{\emph{\{}#1\emph{\}}} % multiple (any number)
\newcommand{\alt}[1]{\emph{(}#1\emph{)}} % alternatives
\newcommand{\altor}[1]{\ensuremath{\mathit{|}}} % alternatives separator
\newcommand{\new}[1]{\underline{#1}}     % additions

\begin{enumerate}
\item
Any \nt{Type} may be prefixed by \opt{\nt{Annotations}}:

\begin{tabbing}
\qquad \= \kill
    \nt{Type}: \\
\qquad            \new{\opt{\nt{Annotations}}} Identifier \opt{TypeArguments} \multi{. \nt{Identifier} \opt{\nt{TypeArguments}}} \multi{\term{[]}} \\
\qquad            \new{\opt{\nt{Annotations}}} \nt{BasicType}
\end{tabbing}


% Optionally, two uses of
%   ``\opt{\nt{Annotations}} \nt{Type}''
% can be simplified to
%   ``\nt{Type}''.
% (in ForVarControl, FormalParameterDecls).
% 
% OLD:
%     ForVarControl
%             [final] [Annotations] Type Identifier ForVarControlRest
% NEW:
%     ForVarControl
%             [final] Type Identifier ForVarControlRest
% 
% OLD:
%     FormalParameterDecls:
%             [final] [Annotations] Type FormalParameterDeclsRest]
% NEW:
%     FormalParameterDecls:
%             [final] Type FormalParameterDeclsRest]


\item
To permit annotations on levels of an array (in declarations, not
constructors), change ``\multi{\term{[]}}''  to
``\multi{\new{\opt{\nt{Annotations}}} \term{[]}}''.
(This was abstracted out as
``\nt{BracketsOpt}'' in the 2nd edition of the JLS~\cite{GoslingJSB2000}.)
For example:

\begin{tabbing}
\qquad \= \kill
    \nt{Type}: \\
\qquad            \opt{\nt{Annotations}} Identifier \opt{TypeArguments}\multi{   .   \nt{Identifier} \opt{\nt{TypeArguments}}} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \\
\qquad            \opt{\nt{Annotations}} \nt{BasicType}
\end{tabbing}

Annotations may also appear on varargs (\code{...}):

\begin{tabbing}
\qquad \= \kill
    \nt{FormalParameterDeclsRest}: \\
\qquad             \nt{VariableDeclaratorId} \opt{\term{,} \nt{FormalParameterDecls}} \\
\qquad            \new{\opt{\nt{Annotations}}} \term{...} \nt{VariableDeclaratorId}
\end{tabbing}


\item
Annotations may appear on the receiver type by changing uses of
``\nt{FormalParameters}'' (in
all 5 places it appears in the grammar)
to ``\nt{FormalParameters} \new{\opt{Annotations}}''.  For example:

\begin{tabbing}
\qquad \= \kill
\nt{VoidMethodDeclaratorRest}: \\
\qquad            \nt{FormalParameters} \new{\opt{\nt{Annotations}}} \opt{throws \nt{QualifiedIdentifierList}} \nt{(} \nt{MethodBody} \altor{} \term{;} \nt{)}
\end{tabbing}


\item
Annotations may appear on the type parameter declaration in a class or method
declaration.

\begin{tabbing}
\qquad \= \kill
\nt{TypeParameter}: \\
\qquad            \new{\opt{\nt{Annotations}}} \nt{Identifier} \opt{extends \nt{Bound}}
\end{tabbing}

Annotations may also appear on the wildcard in any type argument.
A wildcard is the declaration of an anonymous (unnamed) type parameter.

\begin{tabbing}
\qquad \= \kill
\nt{TypeArgument}: \\
\qquad            \new{\opt{\nt{Annotations}}} ?\ \opt{\nt{(} extends \altor{} super \nt{)} \nt{Type}}
\end{tabbing}


\end{enumerate}



\subsection{Target meta-annotations for type annotations\label{target-meta-annotation}}

Java uses the \code{@Target} meta-annotation as a machine-checked way of
expressing where an annotation is intended to appear.  The
\code{ElementType} enum classifies the places an annotation may appear in a
Java program.  JSR 308 adds two new constants to the \code{ElementType}
enum.

\begin{itemize}
\item
\code{ElementType.TYPE\_PARAMETER} stands for a type parameter --- that is,
the declaration of a type variable.  Examples are generic class
declarations \code{class MyClass<T> \ttlcb ... \ttrcb}, generic method
declarations \code{<T> foo(...) \ttlcb ... \ttrcb}, and wildcards
\code{List<?>}, which declare an anonymous type variable.

\item
\code{ElementType.TYPE\_USE} stands for all uses of types.
\end{itemize}

For example, in this declaration:

% Does not need to be "@Target({ElementType.TYPE_USE})" because when the
% annotation argument is an array, it is permitted to supply just one
% element to indicate a singleton array.
\begin{Verbatim}
  @Target(ElementType.TYPE_USE)
  public @interface NonNull { ... }
\end{Verbatim}

\noindent
the \code{@Target(ElementType.TYPE\_USE)} meta-annotation indicates that
\code{@NonNull} may appear on any use of a type.

\code{ElementType.TYPE\_PARAMETER} and \code{ElementType.TYPE\_USE} are
distinct from the existing \code{ElementType.TYPE} enum element
of Java SE 6, which indicates that an annotation may appear on a type
declaration (a class, interface, or enum declaration).  The locations
denoted by \code{ElementType.TYPE\_PARAMETER},
\code{ElementType.TYPE\_USE}, and \code{ElementType.TYPE} are disjoint.

If an annotation is not meta-annotated with \<@Target> (which would be poor
style), then the compiler treats the annotation as if it is
meta-annotated with all of the \code{ElementType} enum constants.

The compiler applies an annotation to every target that is consistent with
its meta-annotation.  The order of annotations is not used to disambiguate.
As in Java SE 6, the compiler issues an error if a programmer places an
annotation in a location not permitted by its Target meta-annotation.  (The
compiler issues the error even if no annotation processor is being run.)
% The Target Javadocs state
%   If such a meta-annotation is present, the compiler will enforce the
%   specified usage restriction.
% (See http://java.sun.com/javase/6/docs/api/java/lang/annotation/Target.html.)



\section{Compiler modifications\label{mods}\label{compiler}}

% This section indicates the tools and specifications that must be modified
% in order for the Java language and tools to support JSR 308.
% 
% 
% \subsection{Compiler\label{compiler}}


When generating \code{.class} files, the compiler must emit the attributes
described in Section~\ref{class-file}.
% (The JLS needs to be updated to so state.)

The compiler is required to preserve annotations in the class file.  More
precisely, if an expression has an annotated type (and the annotation has
class file or runtime retention), and that expression is represented
in the compiled class file, then the annotation must be present, in the
compiled class file, on the type of the compiled representation of the
expression.  For expressions within a field initializer or a static
initializer block, the compiled representation might be in an \code{<init>}
or \code{<clinit>} method, or in a helper method called by them.

If the compiler optimizes away an expression, then it may also
optimize away the annotation.  (Exception:  when a type cast
is optimized away without optimizing away its argument, the
annotation remains on the argument; see Section~\ref{target_type}.)

The compiler sometimes creates new methods that did not appear in the
source code.  The compiler should annotate these compiler-generated methods
in an appropriate way.  For example, a bridge method is an implementation
strategy used when the erased signature of the actual method being invoked
differs from that of the compile-time method
declaration~\cite[\S15.12.4.5]{GoslingJSB2005}.  The bridge method does
nothing but call an existing method, and in this case, annotations should
be copied from the method being invoked.

%% Cut this -- too compiler-specific.
% and
% constructors for anonymous classes~\cite[\S15.9.5.1]{GoslingJSB2005}.

%% Remarks about javac are not appropriate in a specification.
% (As of Java SE 6, javac does not copy/transfer any annotations from
% original methods to the compiler-generated methods; that is probably a bug
% in javac.  It is, however, perhaps debatable whether \emph{all} annotations
% should be copied.)


\section{Class file format extensions\label{class-file}}

\newcommand{\RuntimeVisibleAnnotations}{\code{Runtime\-Visible\-Annotations}\xspace}
\newcommand{\RuntimeInvisibleAnnotations}{\code{Runtime\-Invisible\-Annotations}\xspace}
\newcommand{\RuntimeInOrVisibleAnnotations}{\code{Runtime}\-[\code{In}]\code{visible\-Annotations}\xspace}
\newcommand{\RuntimeVisibleParameterAnnotations}{\code{Runtime\-Visible\-Parameter\-Annotations}\xspace}
\newcommand{\RuntimeInvisibleParameterAnnotations}{\code{Runtime\-Invisible\-Parameter\-Annotations}\xspace}
\newcommand{\RuntimeInOrVisibleParameterAnnotations}{\code{Runtime}\-[\code{In}]\code{visible\-Parameter\-Annotations}\xspace}
\newcommand{\RuntimeInOrVisibleAnnotationsOrParameterAnnotations}{\code{Runtime}\-[\code{In}]\code{visible}[\code{Parameter}]\code{Annotations}\xspace}
\newcommand{\RuntimeVisibleTypeAnnotations}{\code{Runtime\-Visible\-Type\-Annotations}\xspace}
\newcommand{\RuntimeInvisibleTypeAnnotations}{\code{Runtime\-Invisible\-Type\-Annotations}\xspace}
\newcommand{\RuntimeInOrVisibleTypeAnnotations}{\code{Runtime}\-[\code{In}]\code{visible\-Type\-Annotations}\xspace}

% Don't use this in section headings, as that throws Hevea off.
\newcommand{\extendedannotation}{\code{extend\-ed\-\_anno\-ta\-tion}\xspace}


This section defines how to store type annotations in a Java class file.
It also defines how to store local variable annotations, which are
permitted in Java SE 6 source code but are discarded by the compiler.


\paragraph{Why store type annotations in the class file?}

The class file format represents the type of every variable and expression
in a Java class, including all temporaries and values stored on the stack.
(Sometimes the representation is explicit, such as via the
\code{StackMapTable} attribute, and sometimes it is implicit.)
Since JSR 308 permits annotations to be added to a type, the class file
format should be updated to continue to represent the full, annotated type
of each expression.


More pragmatically, Java annotations must be stored in the class file for two reasons.

First, annotated \emph{signatures} (public members) must be available to
tools that read class files.  For example, a type-checking compiler
plug-in~\cite{JSR269,PapiACPE2008} needs to read annotations when compiling
a client of the class file.  The Checker Framework
(\myurl{http://types.cs.washington.edu/checker-framework/}) is
one way to create such plug-ins.
% (an annotation processor)
% , as described in Section~\ref{compile-time})

Second, annotated method \emph{bodies} must be present to permit checking
the class file against the annotations.  This is necessary to give
confidence in an entire program, since its parts (class files) may
originate from any source.  Otherwise, it would be necessary to simply
trust annotated classes of unknown provenance~\cite{BurdyHP2007}.
% so load-time checking (by a plug-in to the bytecode verifier)
% % as described in Section~\ref{load-time})
% is required to ensure
% that the guarantees of the source language are enforced at run time.
% (A third \emph{non}-goal is providing reflective access within method
% bodies.)
% ; the key use is class file tools

% There are a wide variety of class file tools that might want the
% annotations.  One specific reason for class file retention is the ability
% to pass information to code generation, a JIT, etc., when a compiler is
% compiling to Java as a target language.


\paragraph{How Java SE 6 stores annotations in the class file}

% Class files already store annotations in the form of
% ``attributes''.

In Java SE 6, an annotation is stored in the class file in an
\emph{attribute}~\cite{JSR175,LindholmY99:CFF5}.  An attribute 
associates data with a program element (a
method's bytecodes, for instance, are stored in a \code{Code}
attribute of the method). The \RuntimeVisibleParameterAnnotations stores formal parameter annotations that are accessible at runtime using reflection, and the
\RuntimeInvisibleParameterAnnotations attribute stores formal parameter annotations
that are not accessible at runtime.
\RuntimeVisibleAnnotations and 
\RuntimeInvisibleAnnotations are analogous, but for annotations on fields,
methods, and classes.

These attributes contain arrays of
\code{annotation} structure elements, which in turn contain arrays of
\code{element\_value} pairs.  The \code{element\_value} pairs store
the names and values of an annotation's arguments.

Annotations on a field are stored as attributes of the field's 
\code{field\_info} structure~\cite[\S 4.6]{LindholmY99:CFF5}.
Annotations on a method are stored as attributes of the method's
\code{method\_info} structure~\cite[\S 4.7]{LindholmY99:CFF5}.
Annotations on a class are stored as attributes of the class's
\code{attributes} structure~\cite[\S 4.2]{LindholmY99:CFF5}.

Generic type information is stored in a different way in the class file, in
a signature attribute.  Its details are not germane to the current
discussion.


\paragraph{Changes in JSR 308}
JSR 308 introduces two new attributes:
\RuntimeVisibleTypeAnnotations and
\RuntimeInvisibleTypeAnnotations. These attributes are
structurally identical to the \RuntimeVisibleAnnotations and
\RuntimeInvisibleAnnotations attributes described above with one
exception: rather than an array of \code{annotation} elements,
\RuntimeVisibleTypeAnnotations and
\RuntimeInvisibleTypeAnnotations contain an array of
\extendedannotation elements, which are described in
Section~\ref{class-file:ext}.

% There's no point in separating the type annotations into two attributes,
% one for class/field/method and one for formal parameters, so we don't do
% so.

A type annotation is stored in a \RuntimeInOrVisibleTypeAnnotations attribute
on the smallest enclosing class, field, or method.

Type annotations targeting declaration types (e.g. field, method return type)
will appear in the \RuntimeInOrVisibleTypeAnnotations attribute.
Section~\ref{disambiguating} discusses disambiguating type and declaration
annotations.

\paragraph{Backward compatibility}
For backward compatibility, JSR 308 uses new attributes for storing
the type annotations.  In other words, JSR 308 merely reserves the
names of a few new attributes and specifies their layout.
JVMs ignore unknown
attributes.
JSR 308 does
not alter the way that existing annotations on classes, methods, method parameters,
and fields are stored in the class file.
% , except those on parameterized types or arrays.
JSR 308 mandates no changes to the processing of existing annotation locations;
in the absence of other changes to the class file format,
class files generated from programs that use no new
annotations will be identical to those generated by a standard Java SE 6
% (that is, pre-extended-annotations)
compiler.
Furthermore, the bytecode array will be identical between two programs that
differ only in their annotations.
Attributes have no effect on the bytecode array, because they exist outside
it; however, they can represent properties of it by referring to the
bytecode (including referring to specific instructions, or bytecode offsets).


\paragraph{To do}
In Java SE 6, the class file stores the types of elements on the stack;
this eliminates the need for byte code verification to perform type
inference for local variables and stack elements.  The class file format
should similarly store the annotations on those types, to aid in annotation
verification in class files.

% StackMapTable is the attribute that defines these.  They are differential
% and rather tricky, but we'll just copy that format.  There is no public
% API, just a defined classfile format.


\subsection{The \code{extended\_annotation} structure\label{class-file:ext}}

The \extendedannotation structure has the following format:

\begin{Verbatim}
extended_annotation {
    // Original fields from "annotation" structure:
    u2 type_index;
    u2 num_element_value_pairs;
    {
        u2 element_name_index;
        element_value value;
    } element_value_pairs[num_element_value_pairs];
    // New fields in JSR 308:
    u1 target_type;    // the type of the targeted program element, see Section 4.2
    union {
        offset_target;
        localvar_target;
        methodparam_target;
        field_target;
        typeparam_target;
        typeparam_bound_target;
        typearg_target;
        supertype_target;
        typeindex_target;
        wildcard_bound_target;
        empty_target;
    } target_info;  // uniquely identifies the targeted program element, see Section 4.3
}
\end{Verbatim}

We first briefly recap
the three fields of \code{annotation}~\cite[\S 4.8.15]{LindholmY99:CFF5}.

\begin{itemize}
\item \code{type\_index} is an index into the constant pool indicating the
  annotation type for this annotation.
\item \code{num\_element\_value\_pairs} is a count of the
  \code{element\_value\_pairs} that follow.
\item Each \code{element\_value\_pairs} table entry represents a single
  element-value pair in the annotation (in the source code, these are the
  arguments to the annotation):  \code{element\_name\_index} is a
  constant pool entry for the name of the annotation type element, and
  \code{value} is the corresponding value~\cite[\S 4.8.15.1]{LindholmY99:CFF5}.
\end{itemize}

Compared to \code{annotation},
the \extendedannotation structure contains two additional fields.
These fields implement a discriminated (tagged) union type:
field \code{target\_type} is the tag (see
Section~\ref{class-file:ext:target_type}), and its value determines the
size and
contents of \code{target\_info} (see Section~\ref{class-file:ext:target_info}).


\subsection{The \code{target\_type} field\label{class-file:ext:target_type}\label{target_type}}

The \code{target\_type} field denotes the type of program element that
the annotation targets, such as whether the annotation is on a field, a
method receiver, a cast, or some other location.
Figure~\ref{tbl:target_types} gives the value of \code{target\_type} for
every possible annotation location.


\def\unused{\ensuremath{*}}
\ifhevea
  \def\rlapunused{\relax}
\else
  \def\rlunused{\rlap{\unused}}
\fi


\begin{figure}[thp!]
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
{\bf Annotation target} & {\bf \code{target\_type} value} & {\bf \code{target\_info} definition} \\ \hline
%% The canonical location for this information is
%%   langtools/src/share/classes/com/sun/tools/javac/comp/TargetType.java
%% so whenever that is updated, this table should be as well.
method type parameter                           & \code{0x20} & \S\ref{class-file:ext:ri:mtp} \\
~~~~\ldots type argument or array element type  & \code{0x21}\rlunused & Java does not support \\
class type parameter                            & \code{0x22} & \S\ref{class-file:ext:ri:mtp} \\
~~~~\ldots type argument or array element type  & \code{0x23}\rlunused & Java does not support \\
\hline
method receiver                                 & \code{0x06} & \S\ref{class-file:ext:ri:receiver} \\
~~~~\ldots type argument or array element type  & \code{0x07}\rlunused & Future extension to JSR 308 \\ % +\S\ref{class-file:ext:ri:typearg}
method return type                              & \code{0x0A} & \S\ref{class-file:ext:ri:return} \\
~~~~\ldots type argument or array element type  & \code{0x0B} & +\S\ref{class-file:ext:ri:typearg} \\
method parameter                                & \code{0x0C} & \S\ref{class-file:ext:ri:parameters} \\
~~~~\ldots type argument or array element type  & \code{0x0D} & +\S\ref{class-file:ext:ri:typearg} \\
field                                           & \code{0x0E} & \S\ref{class-file:ext:ri:return} \\
~~~~\ldots type argument or array element type  & \code{0x0F} & +\S\ref{class-file:ext:ri:typearg} \\
class type parameter bound                      & \code{0x10} & \S\ref{class-file:ext:ri:tpbound} \\
~~~~\ldots type argument or array element type  & \code{0x11} & +\S\ref{class-file:ext:ri:typearg} \\
method type parameter bound                     & \code{0x12} & \S\ref{class-file:ext:ri:tpbound} \\
~~~~\ldots type argument or array element type  & \code{0x13} & +\S\ref{class-file:ext:ri:typearg} \\
class \code{extends}/\code{implements}          & \code{0x14} & \S\ref{class-file:ext:ri:extends} \\
~~~~\ldots type argument or array element type  & \code{0x15} & +\S\ref{class-file:ext:ri:typearg} \\
exception type in \code{throws}                 & \code{0x16} & \S\ref{class-file:ext:ri:throws} \\
~~~~\ldots type argument or array element type  & \code{0x17}\rlunused & forbidden by Java \\
wildcard bound                                  & \code{0x1C} & \S\ref{class-file:ext:ri:wildcard} \\
~~~~\ldots type argument or array element type  & \code{0x1D} & +\S\ref{class-file:ext:ri:typearg} \\
\hline
typecast                                        & \code{0x00} & \S\ref{class-file:ext:ri:typecast} \\
~~~~\ldots type argument or array element type  & \code{0x01} & +\S\ref{class-file:ext:ri:typearg} \\
type test (\code{instanceof})                   & \code{0x02} & \S\ref{class-file:ext:ri:typecast} \\
~~~~\ldots type argument or array element type  & \code{0x03} & +\S\ref{class-file:ext:ri:typearg} \\
object creation (\code{new})                    & \code{0x04} & \S\ref{class-file:ext:ri:typecast} \\
~~~~\ldots type argument or array element type  & \code{0x05} & +\S\ref{class-file:ext:ri:typearg} \\
local variable                                  & \code{0x08} & \S\ref{class-file:ext:ri:localvar} \\
~~~~\ldots type argument or array element type  & \code{0x09} & +\S\ref{class-file:ext:ri:typearg} \\
type argument in constructor call               & \code{0x18} & \S\ref{class-file:ext:ri:con-typearg} \\
~~~~\ldots type argument or array element type  & \code{0x19} & +\S\ref{class-file:ext:ri:typearg} \\
type argument in method call                    & \code{0x1A} & \S\ref{class-file:ext:ri:con-typearg} \\
~~~~\ldots type argument or array element type  & \code{0x1B} & +\S\ref{class-file:ext:ri:typearg} \\
class literal                                   & \code{0x1E} & \S\ref{class-file:ext:ri:typecast} \\
~~~~\ldots type argument or array element type  & \code{0x1F} & +\S\ref{class-file:ext:ri:typearg} \\

\hline
\end{tabular}
\end{center}
%BEGIN LATEX
\vspace{-10pt}
%END LATEX
\caption{\label{tbl:target_types}
  Values of \code{target\_type} for each possible target of a type
  annotation.
  Declaration annotations are not included (except those on type parameter
  declarations), because they
  appear in \code{annotation}, not \extendedannotation, attributes
  in the class file.
  Table elements such as local variable, method parameter, and field refer
  to the declaration, not the use, of such elements.
\newline
  Enumeration elements marked \unused{} will never appear in a
  \code{target\_type} field; see Section~\ref{target_type}.
\newline
  The table has three parts.
  The first part contains targets for type parameter declarations
  (\<ElementType.TYPE\_PARAMETER>).  The second and third parts contain
  targets for type uses (\<ElementType.TYPE\_USE>).
  The second part contains targets that are externally visible, such as may
  appear on classes and members --- places that annotations already appear
  in the class file in Java SE 6.
  The bottom half of the table contains targets that only appear inside
  method bodies, where annotations do not appear in Java SE 6 (not even
  local variable annotations written by the programmer).
TO DO: mention the exception table?
}
\end{figure}


Enumeration elements marked \unused{} never appear in a \code{target\_type}
field.  Sometimes this is because annotations cannot be written in that
location, such as because Java prohibits writing the location itself.  In
other cases this is because the annotations were permitted in Java 5, so
there is already a place to store them in the class file
% in \RuntimeInOrVisibleAnnotations or
% \RuntimeInOrVisibleParameterAnnotations
rather than placing them in the new \RuntimeInOrVisibleTypeAnnotations
attribute.  The unused enumeration elements are included for completeness.
%% In what way are they convenient for annotation processors?
% and convenience for annotation processors.


\subsection{The \code{target\_info} field\label{class-file:ext:target_info}}

\code{target\_info} is a structure that contains enough information to
uniquely identify the target of a given annotation.  A different
\code{target\_type} may require a different set of fields, so the structure
of the \code{target\_info} is determined by the value of
\code{target\_type}.

% , and in some cases the size of \code{target\_info} is zero ...

All indexes count from zero.

See Section~\ref{class-file:ext:ri:typearg} for handling of generic
type arguments and arrays.



\subsubsection{Typecasts, type tests, object creation, and class literals\label{class-file:ext:ri:typecast}}

When the annotation's target is a typecast, an \code{instanceof}
expression, a \code{new} expression, or a class literal expression,
\code{target\_info} contains one \code{offset\_target} which has the
following structure:

\begin{Verbatim}
    offset_target {
        u2 offset;
    };
\end{Verbatim}

The \code{offset} field denotes the offset (i.e., within the bytecodes
of the containing method) of the \code{checkcast} bytecode emitted for
the typecast, the \code{instanceof} bytecode emitted for the type tests,
the \code{new} bytecode emitted for the object creation expression,
the \code{ldc(\_w)} bytecode emitted for class literals, or the
\code{getstatic} bytecode emitted for primitive class literals.
Typecast annotations are attached to a single bytecode, not a bytecode range
(or ranges):  the annotation provides information about the type of a
single value, not about the behavior of a code block.
A similar explanation applies to type tests, object creation, and class literals.

For annotated typecasts, the attribute may be attached to a
\code{checkcast} bytecode, or to any other bytecode.  The rationale for
this is that the Java compiler is permitted to omit \code{checkcast}
bytecodes for typecasts that are guaranteed to be no-ops.  For example, a
cast from \code{String} to \code{@NonNull String} may be a no-op for the
underlying Java type system (which sees a cast from \code{String} to
\code{String}).  If the compiler omits the \code{checkcast} bytecode, the
\code{@NonNull} attribute would be attached to the (last) bytecode that
creates the target expression instead.  This approach permits code
generation for existing compilers to be unaffected.

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{offset\_target} appears in the attributes table of a
\code{method\_info} structure.

% The Java compiler must emit a \code{checkcast} bytecode for any annotated
% cast, so that there is a target for the \code{offset} field.  Ordinarily, a
% Java compiler is permitted to omit \code{checkcast} bytecodes for typecasts
% that are guaranteed to be no-ops.  For example, a cast from \code{String}
% to \code{@NonNull String} may be a no-op for the underlying Java type
% system (which sees a cast from
% \code{String} to \code{String}), but it may be significant to the type
% system for the qualified types
% % ; for example, it may be needed for load-time type checking.
% Retaining the \code{checkcast} bytecodes does not change
% behavior, and is unlikely to affect performance.  A JIT will eliminate the
% cast, leading to no runtime performance penalty, and the impact on class
% file size is minimal, especially when compared to the size of the
% annotations themselves.  No \code{checkcast} bytecode need be emitted for
% un-annotated type casts.


\subsubsection{Local variables\label{class-file:ext:ri:localvar}}

When the annotation's target is a local variable,
\code{target\_info} contains one \code{localvar\_target}, which has the
following structure:

\begin{Verbatim}
    localvar_target {
        u2 table_length;
        {
            u2 start_pc;
            u2 length;
            u2 index;
        } table[table_length];
    };
\end{Verbatim}

The \code{table\_length} field specifies the number of entries in the
\code{table} array; multiple entries are necessary because a compiler is
permitted to break a single variable into multiple live ranges with different
local variable indices.
The \code{start\_pc} and \code{length} fields specify the variable's
live range in the bytecodes of the local variable's containing method
(from offset \code{start\_pc} to offset \code{start\_pc + length}).  The
\code{index} field stores the local variable's index in that method.
These fields are similar to those of the optional
\code{LocalVariableTable} attribute~\cite[\S 4.8.12]{LindholmY99:CFF5}.

Storing local variable annotations in the class file raises certain
challenges.  For example, live ranges are not isomorphic to local
variables.  Further, a local variable with no live range may not appear in
the class file (but it is also irrelevant to the program).

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{localvar\_target} appears in the attributes table of a
\code{method\_info} structure.

\subsubsection{Method parameters\label{class-file:ext:ri:parameters}}

When the type annotation's target is a method parameter type,
\code{target\_info} contains one \code{methodparam\_target} which
indicates which of the method's formal parameters is being annotated:

\begin{Verbatim}
    methodparam_target {
        u1 parameter_index;
    };
\end{Verbatim}

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{methodparam\_target} appears in the attributes table of a
\code{method\_info} structure.

\subsubsection{Method receivers\label{class-file:ext:ri:receiver}}

When the annotation's target is a method receiver type (or an inner class
constructor receiver type), \code{target\_info} is empty.  More formally, it
contains \code{empty\_target}:

\begin{Verbatim}
    empty_target {
    };
\end{Verbatim}


% TODO: Make the following paragraph consistent with the rest
A \RuntimeInOrVisibleTypeAnnotations attribute targeting
a method receiver appears in the attributes table of a
\code{method\_info} structure.


\subsubsection{Method return type and fields\label{class-file:ext:ri:return}}

% TODO: Specify methodorfield_target
When the type annotation's target is a method return type, a constructor
result, or a field, \code{target\_info} is empty (contains \code{empty\_target}).

% TODO: Make the following paragraph consistent with the rest
A \RuntimeInOrVisibleTypeAnnotations attribute targeting a field
type appears in the attributes table of a \code{field\_info} structure.
A \RuntimeInOrVisibleTypeAnnotations attribute targeting a method return
type appears in the attributes table of a \code{method\_info} structure.

\subsubsection{Type parameters\label{class-file:ext:ri:mtp}}

When the annotation's target is a type parameter of a class or method,
\code{target\_info} contains one \code {typeparam\_info} which has the
following structure:

\begin{Verbatim}
    typeparam_info {
        u1 param_index;
    };
\end{Verbatim}

\code{param\_index} specifies the 0-based index of the type parameter.

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{offset\_target} appears in the attributes table of a
\code{method\_info} structure if it 

\subsubsection{Type parameter bounds\label{class-file:ext:ri:tpbound}}

When the annotation's target is a bound of a type parameter of a class or
method, \code{target\_info} contains one \code{typeparam\_bound\_target}
which has the following structure:

\begin{Verbatim}
    typeparam_bound_target {
        u1 param_index;
        u1 bound_index;
    };
\end{Verbatim}

\code{param\_index} specifies the index of the type parameter, while
\code{bound\_index} specifies the index of the bound.  Consider the following
example:

\begin{Verbatim}
  <T extends @A Object & @B Comparable, U extends @C Cloneable>
\end{Verbatim}

\noindent
Here
\code{@A} has \code{param\_index} 0 and \code{bound\_index} 0,
\code{@B} has \code{param\_index} 0 and \code{bound\_index} 1, and
\code{@C} has \code{param\_index} 1 and \code{bound\_index} 0.

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{typeparam\_bound\_target} appears in the attributes table of a
\code{method\_info} structure if it targets a method type parameter bound,
otherwise, in the \code{attributes} of \code{ClassFile} structure if it
targets a class declaration type parameter bound.

\subsubsection{Constructor and method call type arguments\label{class-file:ext:ri:con-typearg}}

When the annotation's type is a type argument in a constructor call or
a method call, \code{target\_info} has one \code{typearg\_target}
which has the following structure:

\begin{Verbatim}
    typearg_target {
        u2 offset;
        u1 type_index;
    };
\end{Verbatim}

The \code{offset} field denotes the offset (i.e., within the bytecodes
of the containing method) of the \code{new} bytecode emitted for
constructor call, or the
\code{invoke\{interface|special|static|virtual\}} bytecode emitted for
method invocation.  Like type cast type annotations, type argument
annotations are attached to a single bytecode, not a bytecode range.

\code{type\_index} specifies the index of the type argument in the
expression.

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{typeparam\_bound\_target} appears in the attributes table of a
\code{method\_info} structure.


\subsubsection{Class \code{extends} and \code{implements} clauses\label{class-file:ext:ri:extends}}

When the annotation's target is a type in an \code{extends} or
\code{implements} clause, \code{target\_info} has the following
structure:

\begin{Verbatim}
    supertype_target {
        u2 type_index;
    };
\end{Verbatim}

\code{type\_index} specifies the index of the targeted type in the
\code{interfaces} array field of the \code{ClassFile} structure;
simply the value $i$ is used if the annotation is on the $i$th
superinterface type.

% TODO: handle superclass properly
\code{-1} (\code{65535}) is used if the annotation is on the superclass type.

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{supertype\_target} appears in the attributes table of a
\code{ClassFile} structure.


\subsubsection{\code{throws} clauses\label{class-file:ext:ri:throws}}
When the annotation's target is a type in a \code{throws} clause,
\code{target\_info} contains \code{exception\_target} which has the
following structure:

\begin{Verbatim}
    exception_target {
        u2 type_index;
    };
\end{Verbatim}

\code{type\_index} specifies the index of the exception type in the
clause in \code{exception\_index\_table} of \code{Exceptions\_attribute};
simply the value $i$ denotes an annotation on the $i$th exception
type.

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{typeparam\_bound\_target} appears in the attributes table of a
\code{method\_info} structure.


\subsubsection{Wildcard bounds\label{class-file:ext:ri:wildcard}}

When the annotation's target is the bound of a wildcard,
\code{target\_info} contains one \code{wildcard\_bound\_target} which
has the following structure:

\begin{Verbatim}
    wildcard_bound_target {
        u1 wildcard_location_type;   // The location of the wildcard, values as for target_type (Section 4.2)
        {
            ...
        } target_info;  // uniquely identifies the targeted program element, see Section 4.3
    }
\end{Verbatim}

Here are examples:

\noindent
\code{@A} in \code{void m(List<?\ extends @A String> lst) \{ ... \}} is described as:

\begin{Verbatim}
   target_type = WILDCARD_BOUND
   target_info =
     {
       wildcard_location_type = METHOD_PARAMETER (0x0C)
       wildcard_location =
         {
           u1 parameter_index = 0;
         }
     }
\end{Verbatim}

\noindent
\code{@B} in \code{Map<Object, ?\ extends List<@B String>> newMap() \{
  ... \}} is described as (see Section~\ref{class-file:ext:ri:typearg} for
an explanation of \<location\_length> and \<location>):

\begin{Verbatim}
   target_type = WILDCARD_BOUND_GENERIC_OR_ARRAY
   target_info =
   {
     // location of wildcard: type argument of the return type
     wildcard_location_type = RETURN_TYPE_GENERIC_OR_ARRAY;
     wildcard_location =
     {
       // the second type variable
       location_length = 1;
       location = { 1 };
     }
     // the generic information of the annotation itself
     location_length = 1;
     location = { 0 };
   }
\end{Verbatim}

A \RuntimeInOrVisibleTypeAnnotations attribute containing a
\code{wildcard\_bound\_target} appears in the attributes table of

\begin{enumerate}
\item
a \code{ClassFile} structure, if the annotation appears on the class
type parameters, a super class, or a super interface type,

\item
a \code{field\_info}, if the annotation appears on the field type
arguments, or

\item
a \code{method\_info}, if the annotation appears on the method type
parameters, return type, parameter types, exception types, or any type
in its method body.

\end{enumerate}

\code{method\_info} structure.

\subsubsection{Type arguments and array element types\label{class-file:ext:ri:typearg}}

In a parameterized type or array, there are multiple places that an
annotation may appear.  For example, consider the difference among:
\code{@X Map<String, Object>},
\code{Map<@X String, Object>}, and
\code{Map<String, @X Object>},
or the difference  among 
\code{@X String [] []},
\code{String @X [] []}, and
\code{String [] @X []}.
The classfile must distinguish among these locations.

When the annotation's target is within a parameterized type or
array type,
\code{target\_info} contains what it normally would for a
non-parameterized, non-array type
% (e.g., \code{offset} for an annotation on a type argument in a
% typecast, see Section~\ref{class-file:ext:ri:typecast}),
{\em plus} the following fields at the end:

\begin{Verbatim}
    u2 location_length;
    u1 location[location_length];
\end{Verbatim}

The \code{location} field is a list of numbers that represents the annotation
location among the generic type arguments and array levels.
If the type is viewed as a tree, then 
the \code{location} field can be viewed as a path in that tree.
The \code{location\_length} field is the length of the \code{location}
field, which is also the depth of the annotation in the tree.

A parameterized or array type can be viewed as a tree in the following way.  For a parameterized
type, the children of the raw type are the type arguments.  For an array
type, the children are the types of elements at each level; each of these
is itself an array type (of lesser dimensions than the main type), except
for the last one which is a non-array type.  For a 1-dimensional array,
there is only one child, which is a non-array.

For example, the parameterized types
\code{@A Map<@B String, @C List<@D Object>>}
and
\code{@H String @E [] @F [] @G []}
can be viewed as the following trees:

\begin{center}
\resizebox{!}{2cm}{\includegraphics{figures/type-tree}}
\end{center}

\noindent
Thus the annotations are represented in the class file as follows:

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\bf{Annotation} & \bf{\code{location\_length}} & \bf{\code{location}} \\ \hline
\code{@A}       & \multicolumn{2}{c|}{not applicable} \\
\code{@B}       & 1     & 0 \\
\code{@C}       & 1     & 1 \\
\code{@D}       & 2     & 1, 0 \\
\code{@E}       & \multicolumn{2}{c|}{not applicable} \\
\code{@F}       & 1     & 0 \\
\code{@G}       & 1     & 1 \\
\code{@H}       & 1     & 2 \\
\hline
\end{tabular}
\end{center}

Figure~\ref{tbl:locations} shows the values of the
\code{location\_length} and \code{location} fields in an example that
combines both parameterized and array types.

Indexes start at zero.  For a parameterized type, they count from the
left.  For an array type, they count from the first dimension.

% Mahmood says:  By the way, the compiler fails when parsing such types.
\paragraph{To do}
The specification does not indicate how to differentiate \code{@A} and
\code{@B} uniquely in \code{OuterClass<@A String>.InnerClass<@B String>}.



\begin{figure}[t]
\begin{center}

Declaration: \code{@A Map<@B Comparable<@C Object @D [] @E [] @F []>, @G List<@H Document>>}

%BEGIN LATEX
~
%END LATEX

\begin{tabular}{|l|c|c|}
\hline
\bf{Annotation} & \bf{\code{location\_length}} & \bf{\code{location}} \\ \hline
\code{@A}       & \multicolumn{2}{c|}{not applicable} \\
\code{@B}       & 1     & 0 \\
\code{@C}       & 3     & 0, 0, 2 \\
\code{@D}       & 2     & 0, 0 \\
\code{@E}       & 3     & 0, 0, 0 \\
\code{@F}       & 3     & 0, 0, 1 \\
\code{@G}       & 1     & 1 \\
\code{@H}       & 2     & 1, 0 \\
\hline
\end{tabular}
\end{center}
\caption{Values of the \code{location\_length} and \code{location} fields for
a declaration that combines parameterized and array types.\label{tbl:locations}}
\end{figure}



\section{Detailed grammar changes\label{grammar-details}}

This section
gives detailed changes to the \ahref{http://java.sun.com/docs/books/jls/third_edition/html/syntax.html}{grammar} of the Java
language~\cite[ch.~18]{GoslingJSB2005}, based on the conceptually
simple summary from Section~\ref{grammar-summary}. 
Additions are \underline{underlined}.
% , and deletions \sout{crossed out}.

This section is of interest primarily to language tool implementers, such
as compiler writers.  Most users can read just
Sections~\ref{type-annotation-locations} and~\ref{type-annotation-syntax-examples}.

Infelicities in the Java grammar make this section longer than the simple
summary of Section~\ref{grammar-summary}.  Some improvements are
possible (for instance, by slightly refactoring the Java grammar), but this
version attempts to minimize changes to existing grammar productions.


\begin{tabbing}
\qquad \= \kill
\nt{Type}: \\
\qquad \new{\opt{\nt{Annotations}} \nt{UnannType}} \\
\\
\new{\nt{UnannType}}: \\
\qquad            \nt{Identifier} \opt{TypeArguments}\multi{   .   \nt{Identifier} \opt{\nt{TypeArguments}}} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \\
\qquad            \nt{BasicType} \\
\\
\nt{FormalParameterDecls}: \\
\qquad       \opt{\term{final}} \opt{\nt{Annotations}} \nt{\new{Unann}Type} \nt{FormalParameterDeclsRest} \\
\\
\nt{ForVarControl}: \\
\qquad       \opt{\term{final}} \opt{\nt{Annotations}} \nt{\new{Unann}Type} \nt{Identifier} \nt{ForVarControlRest} \\
\\
\nt{MethodOrFieldDecl}: \\
\qquad       \nt{\new{Unann}Type} \nt{Identifier} \nt{MethodOrFieldRest} \\
\\
\nt{InterfaceMethodOrFieldDecl}: \\
\qquad       \nt{\new{Unann}Type} \nt{Identifier} \nt{InterfaceMethodOrFieldRest} \\
\\
\nt{MethodDeclaratorRest}: \\
\qquad            \nt{FormalParameters} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \new{\opt{\nt{Annotations}}} \opt{\term{throws} \nt{QualifiedIdentifierList}} \alt{ \nt{MethodBody} \altor{} \term{;} } \\
 \\
\nt{VoidMethodDeclaratorRest}: \\
\qquad            \nt{FormalParameters} \new{\opt{\nt{Annotations}}} \opt{\term{throws} \nt{QualifiedIdentifierList}} ( \nt{MethodBody} \altor{}   \term{;}  ) \\
 \\
\nt{InterfaceMethodDeclaratorRest}: \\
\qquad            \nt{FormalParameters} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \new{\opt{\nt{Annotations}}} \opt{\term{throws} \nt{QualifiedIdentifierList}}   \term{;} \\
 \\
\nt{VoidInterfaceMethodDeclaratorRest}: \\
\qquad            \nt{FormalParameters} \new{\opt{\nt{Annotations}}} \opt{\term{throws} \nt{QualifiedIdentifierList}}   \term{;} \\
 \\
\nt{ConstructorDeclaratorRest}: \\
\qquad            \nt{FormalParameters} \new{\opt{\nt{Annotations}}} \opt{\term{throws} \nt{QualifiedIdentifierList}} \nt{MethodBody} \\
 \\
% Only used for throws clause
\nt{QualifiedIdentifierList}: \\
\qquad        \new{\opt{\nt{Annotations}}} \nt{QualifiedIdentifier} \multi{ \term{,}   \new{\opt{\nt{Annotations}}} \nt{QualifiedIdentifier} } \\
\\
\nt{Primary}: \\
\qquad        ... \\
\qquad        \nt{BasicType} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \term{.class} \\
 \\
\nt{IdentifierSuffix}: \\
\qquad        \new{\opt{\nt{Annotations}}} \term{[} \alt{ \term{]} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \term{.class} \altor{} \nt{Expression} \term{]}} \\
\qquad        ... \\
 \\
\nt{VariableDeclaratorRest}: \\
\qquad        \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \opt{\term{=} \nt{VariableInitializer}} \\
 \\
\nt{ConstantDeclaratorRest}: \\
\qquad        \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \opt{\term{=} \nt{VariableInitializer}} \\
 \\
\nt{VariableDeclaratorId}: \\
\qquad       \nt{Identifier} \multi{\new{\opt{\nt{Annotations}}} \term{[]}} \\
 \\
\nt{FormalParameterDeclsRest}: \\
\qquad       \nt{VariableDeclaratorId} \opt{\term{,} \nt{FormalParameterDecls}} \\
\qquad        \new{\opt{\nt{Annotations}}} \term{...} \nt{VariableDeclaratorId} \\
 \\
\nt{TypeParameter}: \\
\qquad            \new{\opt{\nt{Annotations}}} \nt{Identifier} \opt{extends \nt{Bound}}
\end{tabbing}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Non-normative text follows
%%%

\label{page:non-normative-start}

\newpage
\appendix

\section{Example use of type annotations:  Type qualifiers\label{type-qualifiers}}

One example use of annotation on types is to create custom type qualifiers
for Java,
such as \code{@NonNull}, \code{@ReadOnly}, \code{@Interned}, or \code{@Tainted}.
Type qualifiers are modifiers on a type; a declaration that uses a
qualified type provides extra
information about the declared variable.
A designer can define new type
qualifiers using Java annotations, and can provide compiler plug-ins to check
their semantics (for instance, by issuing lint-like warnings during
compilation).
A programmer can then use these type qualifiers
throughout a program to obtain additional guarantees at compile time
about the program.

The type system defined by the type qualifiers does not change Java
semantics, nor is it used by the Java compiler or run-time system.  Rather,
it is used by the checking tool, which can be viewed as performing
type-checking on this richer type system.  (The qualified type is usually
treated as a subtype or a supertype of the unqualified type.)
As an example, a variable of type \code{Boolean} has one of the values
\code{null}, \code{TRUE}, or \code{FALSE} (more precisely, it is null or it
refers to a value that is equal to \code{TRUE} or to \code{FALSE}\@).  A
programmer can depend on this, because the Java compiler guarantees it.
Likewise, a compiler plug-in can guarantee that a variable of type
\code{@NonNull Boolean} has one of the values \code{TRUE} or \code{FALSE}
(but not \code{null}), and a programmer can depend on this.  Note that a
type qualifier such as \code{@NonNull} refers to a type, not a variable,
though JSR 308 could be used to write annotations on variables as well.

Type qualifiers can help prevent errors and make possible a variety of
program analyses.  Since they are user-defined, developers can create
and use the type qualifiers that are most appropriate for their
software.

A system for custom type qualifiers requires
extensions to Java's annotation system, described in this document; the
existing Java SE 6 annotations are inadequate.
Similarly to type qualifiers, other pluggable type
systems~\cite{Bracha2004} and similar lint-like checkers also require these
extensions to Java's annotation system.

Our key goal is to create a type qualifier system that is compatible with
the Java language, VM, and toolchain.
Previous proposals
for Java type qualifiers are incompatible with the existing Java language
and tools, are too inexpressive, or both.
The use of annotations for custom type qualifiers has a number of
benefits over new Java keywords or special comments. First, Java
already implements annotations, and Java SE 6 features a framework
for compile-time annotation processing. This allows JSR 308 to
build upon existing stable mechanisms and integrate with the Java
toolchain, and it promotes the maintainability and simplicity of the
modifications. Second, since annotations do not affect the runtime
semantics of a program, applications written with custom type
qualifiers are backward-compatible with the vanilla JDK\@.
No modifications to the virtual machine are necessary.

Four compiler plug-ins that perform type qualifier type-checking, all built
using JSR 308, are distributed at the JSR 308 webpage,
\myurl{http://types.cs.washington.edu/jsr308/}.  The four checkers, respectively,
help to prevent and detect null pointer errors (via a \code{@NonNull}
annotation), equality-checking errors (via a \code{@Interned} annotation),
mutation errors (via the Javari~\cite{BirkaE2004,TschantzE2005} type
system), and mutation errors (via the IGJ~\cite{ZibinPAAKE2007} type
system).  A paper~\cite{PapiACPE2008} discusses experience
in which these plug-ins exposed bugs in real programs.


\subsection{Examples of type qualifiers\label{type-qualifier-examples}}

The ability to place annotations on arbitrary occurrences of a type
improves the expressiveness of annotations, which has many benefits for
Java programmers.  Here we mention just one use that is enabled by extended
annotations, namely the creation of type qualifiers.
(Figure~\ref{fig:example} gives an example of the use of type qualifiers.)

\begin{figure*}[t]
\begin{center}

%% Hevea handles Verbatim, but not its commandchars or numbers options.
%% I tried "%BEGIN IMAGE" here, but it didn't work.
%BEGIN LATEX
\begin{quote}                   % avoid line numbers in left column
% \newcommand{\NonNull}[1]{@NonNull }
\newcommand{\NonNull}[1]{\relax}
\begin{Verbatim}[commandchars=\\\[\],numbers=left,numbersep=6pt]
@DefaultQualifier("NonNull")                    \label[NonNullDefault]
class DAG {

    Set<\NonNull Edge> edges;                   \label[edgesNonNull]

    // ...

    \NonNull List<\NonNull Vertex> getNeighbors(@Interned @Readonly Vertex v) @Readonly { \label[getNeighbors]\label[InternedAnnotation]
        \NonNull List<\NonNull Vertex> neighbors = new LinkedList<\NonNull Vertex>();
        for (\NonNull Edge e : edges)           \label[eNonNull]
            if (e.from() == v)                  \label[useE1]\label[objectequality]
                neighbors.add(e.to());          \label[useE2]
        return neighbors;
    }
}
\end{Verbatim}
\end{quote}
\vspace{-\baselineskip}
%END LATEX

\begin{rawhtml}
<DIV CLASS="center"><PRE CLASS="verbatim"> 1  @DefaultQualifier("NonNull")  <a name="NonNullDefault"></a>
 2  class DAG {
 3
 4      Set&lt;Edge&gt; edges;          <a name="edgesNonNull"></a>
 5
 6      // ...
 7
 8      List&lt;Vertex&gt; getNeighbors(@Interned @Readonly Vertex v) @Readonly { <a name="getNeighbors"></a><a name="InternedAnnotation"></a>
 9          List&lt;Vertex&gt; neighbors = new LinkedList&lt;Vertex&gt;();
10          for (Edge e : edges)                <a name="eNonNull"></a>
11              if (e.from() == v)              <a name="useE1"></a><a name="objectequality"></a>
12                  neighbors.add(e.to());      <a name="useE2"></a>
13          return neighbors;
14      }
15  }
</PRE></DIV>
\end{rawhtml}

\end{center}

\caption{
The \code{DAG} class, which represents a directed acyclic graph,
illustrates how type qualifiers might be written by a
programmer and checked by a type-checking plug-in in order to detect or
prevent errors.
% Most programs would use only a subset of these annotations.
\newline
\textbf{(1)}
The \code{@DefaultQualifier("NonNull")} annotation (line~\ref{NonNullDefault})
indicates that no reference in the \code{DAG}
class may be null (unless otherwise annotated).  It is equivalent to
writing line~\ref{edgesNonNull} as ``\code{@NonNull Set<@NonNull Edge> edges;}'',
for example.
% The @NonNull annotation on line~\ref{eNonNull}
This guarantees that the uses
of \code{edges} on line~\ref{eNonNull}, and \code{e} on lines~\ref{useE1} and~\ref{useE2}, cannot cause
a null pointer exception.
% That annotation is correct because each
% element of \code{edges} is non-null, as indicated on
% line~\ref{edgesNonNull}.
Similarly, the (implicit) \code{@NonNull} return type of \code{getNeighbors()} (line~\ref{getNeighbors})
enables its clients to depend on the fact that it will always return a
\code{List}, even if \code{v} has no neighbors.
\newline
\textbf{(2)}
The two \code{@Readonly} annotations on method \code{getNeighbors}
(line~\ref{getNeighbors}) guarantee to clients that the method does not
modify, respectively, its \code{Vertex} argument or its \code{DAG} receiver
(including its \code{edges} set or any edge in that set).
The lack of a \code{@Readonly} annotation on the return value indicates
that clients are free to modify the returned \code{List}.
\newline
\textbf{(3)}
The \code{@Interned} annotation on line~\ref{InternedAnnotation} (along
with an \code{@Interned} annotation on the return type in the declaration
of \code{Edge.from()}, not shown) indicates that
the use of object equality (\code{==}) on line~\ref{objectequality} is a
valid optimization.  In the absence of such annotations, use of the
\code{equals} method is preferred to \code{==}.
% \end{itemize}
}

\label{fig:example}
\end{figure*}


As an example of how JSR 308 might be used, consider a
\code{@NonNull} type qualifier that signifies that a variable should
never be assigned \code{null}~\cite{Detlefs96,Evans96,Detlefs-etal98,FahndrichL2003,ChinMM2005}.
% The code in Figure~\ref{fig:example}
% demonstrates \code{@NonNull} in a sample method.
A programmer can
annotate any use of a type with the \code{@NonNull} annotation.
A compiler plug-in would check that a \code{@NonNull} variable is never
assigned a possibly-\code{null} value, thus enforcing the \code{@NonNull}
type system.

%% Commented out to avoid complaints from Sun.
% A pair
% of plug-ins would check that \code{@NonNull} variables are never
% assigned a possibly-\code{null} value: one plug-in for the compiler, which
% would traverse a program's abstract syntax tree and use the compiler's
% API to report any errors it finds, and another plug-in for the virtual
% machine that would analyze annotation information stored in the class
% file when the class is loaded. The compile-time checker is needed during development
% to alert a programmer of violations of a type qualifier's semantics. The
% load-time checker is equally important, so
% that the guarantees provided by the type qualifier are extended to the
% user whenever the program is run.



\code{@Readonly} and \code{@Immutable} are other examples of useful type
qualifiers~\cite{ZibinPAAKE2007,BirkaE2004,TschantzE2005,GreenfieldboyceF2005,KnieselT2001,SkoglundW2001,PoratBKM2000}.
Similar to C's \code{const}, an object's internal state may not be modified
through references that are declared \code{@Readonly}. A type qualifier
designer would create a compiler plug-in (an annotation processor) to check
the semantics of \code{@Readonly}.  For instance, a method may only be
called on a \code{@Readonly} object if the method was declared with a
\code{@Readonly} receiver.
(Each non-static method has an implicit parameter, \code{this}, which is
called the \emph{receiver}.)
\code{@Readonly}'s immutability guarantee can
help developers avoid accidental modifications, which are often manifested
as run-time errors.
An immutability annotation can also improve performance.
The Access Intents mechanism of WebSphere Application Server already
incorporates such functionality:
a programmer can indicate that a particular method (or all methods) on
an Enterprise JavaBean is readonly.

Additional examples of useful type qualifiers abound.  We mention just a
few others.
% Java uses \code{final} to indicate a reference may not be assigned to (this
% is orthogonal to the notion of immutability of the referred-to object).
C uses the \code{const}, \code{volatile}, and \code{restrict} type qualifiers.
%
Type qualifiers \code{YY} for two-digit year strings and \code{YYYY} for
four-digit year strings helped to detect, then verify the absence of, Y2K
errors~\cite{ElsmanFA99}.
%
Expressing units of measurement (e.g., SI units such as meter, kilogram,
second) can prevent errors in which a program mixes incompatible
quantities; units such as dollars can prevent other errors.
%
Range constraints, also known as ranged types, can indicate that a
particular \code{int} has a value between 0 and 10; these are often
desirable in realtime code and in other applications, and are supported in
languages such as Ada and Pascal.
%
Type qualifiers can indicate data that originated from an untrustworthy
source~\cite{PalsbergO95,VolpanoS97}; examples for C include \code{user} vs.\ \code{kernel} indicating user-space and
kernel-space pointers in order to prevent attacks on operating systems~\cite{JohnsonW2004}, and
\code{tainted} for strings that originated in user input and that should
not be used as a format string~\cite{ShankarTFW2001}.
%
A \code{localizable} qualifier can indicate where translation of
user-visible messages should be performed.  Annotations can
indicate other
properties of its contents, such as the format or encoding of a string
(e.g., XML, SQL, human language, etc.).
%  (multibyte, UTF, etc.)
% Add a citation to the Microsoft multibyte/unibyte work; I can't find one.
%
\code{Local} and \code{remote} qualifiers can indicate whether particular
resources are available on the same machine or must be retrieved over the
network.
%
An \code{interned} qualifier can indicate which objects have been converted
to canonical form and thus may be compared via reference equality.
Type qualifiers such as \code{unique}
and \code{unaliased} can express properties about pointers and
aliases~\cite{Evans96,ChinMM2005}; other qualifiers can detect and prevent
deadlock in concurrent programs~\cite{foster:pldi02,aiken:pldi03}.
A \code{ThreadSafe} qualifier~\cite{Goetz2006} could indicate that a given
field should contain a thread-safe implementation of a given interface;
this is more flexible than annotating the interface itself to require that
\emph{all} implementations must be thread-safe.
%
Annotations can identify performance characteristics or goals; for
example, some collections should not be iterated over, and others should
not be used for random access.
%
Annotations (both type qualifiers and others) can specify cut points in
aspect-oriented programming (AOP\@)~\cite{EichbergM2004}.
Flow-sensitive type qualifiers~\cite{foster:pldi02} can express typestate
properties such as whether a file is in the open, read, write, readwrite,
or closed state, and can guarantee that a file is opened for reading before
it is read, etc.  The Vault language's type guards and capability states are
similar~\cite{DelineF2001}.


\subsection{Example tools that do pluggable type-checking for type qualifiers\label{type-qualifier-tools}}

The Checker Framework
(\myurl{http://types.cs.washington.edu/checker-framework/})
gives a way to create pluggable type-checkers.  A pluggable type-checker
verifies absence of certain bugs (and also verifies correct usage of type
qualifiers).  The Checker Framework is distributed with a set of example
type-checkers.  The Checker Framework is built on the Type Annotations (JSR
308) syntax, though it also permits annotations to be written in comments
for compatibility with previous versions of Java.



\section{Discussion of Java language syntax extensions\label{syntax-discussion}}

In Java SE 6, annotations can be written only on method parameters
and the declarations of packages, classes, methods, fields, and local variables.
Additional annotations are necessary in order to fully specify Java classes and
methods.


\subsection{Examples of annotation syntax\label{type-annotation-syntax-examples}}

This section gives examples of the annotation syntax specified in
Sections~\ref{type-annotation-locations} and~\ref{grammar-details}.
This list is not necessarily exhaustive (but if you notice something
missing, let us know so that we can add it).
Section~\ref{type-annotation-use-cases} motivates annotating these
locations by giving the meaning of annotations that need to be applied to
these locations.

% Bill Pugh suggests using @Foo and @Bar here, so avoid giving people the
% impression that we are proposing specific annotations.  But I think that
% makes the discussion unnecessarily abstract and thus harder to follow.

\newcommand{\preverbnegspace}{\vspace{-5pt}}

% This list should perhaps be given in the same order as figure 1 (and
% maybe make that explicit in both places).

\begin{itemize}

\item for generic type arguments to parameterized classes:
\preverbnegspace
\begin{Verbatim}
  Map<@NonNull String, @NonEmpty List<@Readonly Document>> files;
\end{Verbatim}

\item for generic type arguments in a generic method or constructor invocation:
\preverbnegspace
\begin{Verbatim}
  o.<@NonNull String>m("...");
\end{Verbatim}

\item for type parameter bounds and wildcard bounds:
\preverbnegspace
\begin{Verbatim}
  class Folder<F extends @Existing File> { ... }
  Collection<? super @Existing File>
\end{Verbatim}

\item for type parameters:
\preverbnegspace
\begin{Verbatim}
  interface WonderfulList<@Reified E> { ... }
\end{Verbatim}
% Niko Matsakis gave another example in email of 
% Wed, 25 Feb 2009 11:57:37 +0100

\item for class inheritance:
\preverbnegspace
\begin{Verbatim}
  class UnmodifiableList<T> implements @Readonly List<@Readonly T> { ... }
\end{Verbatim}

\item for \code{throws} clauses:
\preverbnegspace
\begin{Verbatim}
  void monitorTemperature() throws @Critical TemperatureException { ... }
\end{Verbatim}

\item for method receivers:
\preverbnegspace
\begin{Verbatim}
  public String toString() @Readonly { ... }
  public void write() @Writable throws IOException { ... }
\end{Verbatim}

\preverbnegspace
It is not currently possible to express constraints on the generic
parameters of the receiver.  See
Section~\ref{receiver-type-parameter-annotations}.

\item for constructor declaration return types:

\preverbnegspace
% TODO:  Use a more realistic example.
\begin{Verbatim}
  class Invocation {
    @Immutable Invocation() { ... }
    ...
  }
\end{Verbatim}
\preverbnegspace

Note that the result of a constructor is different from the receiver.  The
receiver only exists for inner class constructors.  It is the containing
object, and in the body of the constructor it is referred to as
\code{\emph{Supertype}.this}.  In the constructor body, the result is referred to as
\code{this}.  In any non-constructor, the receiver (if any) is referred to
as \code{this}.

TO DO:  Are generic type parameters possible on the constructor result
annotation?


\item for arrays:
\preverbnegspace
\begin{Verbatim}
  @Readonly Document [][] docs1 = new @Readonly Document [2][12]; // array of arrays of read-only documents
  Document @Readonly [][] docs2 = new Document @Readonly [2][12]; // read-only array of arrays of documents
  Document[] @Readonly [] docs3 = new Document[2] @Readonly [12]; // array of read-only arrays of documents
\end{Verbatim}

\preverbnegspace
This syntax permits independent annotations for each distinct level of
array, and for the elements.
% ; see Section~\ref{array-syntax} for alternative syntaxes.

%%% Above this point, the annotations could appear in the signature.
%%% Below this point, they can appear only in a method (or initializer) body.

\item for typecasts:
\preverbnegspace
\begin{Verbatim}
  myString = (@NonNull String) myObject;
\end{Verbatim}
\preverbnegspace
It is not permitted to omit the Java type, as in
\code{myString = (@NonNull) myObject;}; see
Sections~\ref{type-annotation-use-cases} and~\ref{implicit-java-types-in-casts}.

\item for constructor invocation results:

\preverbnegspace
\begin{Verbatim}
  new @Interned MyObject()
\end{Verbatim}
\preverbnegspace

For generic constructors (JLS \ahref{\jlsEightEightFourURL}{\S8.8.4}), the
annotation follows the explicit type arguments (JLS
\ahref{\jlsFifteenNine}{\S15.9}):

\preverbnegspace
\begin{Verbatim}
  new <String> @Interned MyObject()
\end{Verbatim}

\item for type tests:
\preverbnegspace
\begin{Verbatim}
  boolean isNonNull = myString instanceof @NonNull String;
\end{Verbatim}
\preverbnegspace
It is not permitted to omit the Java type, as in
\code{myString instanceof @NonNull}; see
Sections~\ref{type-annotation-use-cases} and~\ref{implicit-java-types-in-casts}.

\item for object creation:
\preverbnegspace
\begin{Verbatim}
  new @NonEmpty @Readonly List<String>(myNonEmptyStringSet)
\end{Verbatim}

\item for class literals:
\preverbnegspace
\begin{Verbatim}
  Class<@NonNull String> c = @NonNull String.class;
\end{Verbatim}

% It's rather unfortunate that programmers cannot write the even more useful
%   List<String>.class
% because Java 5 didn't permit that.  It should perhaps be fixed.

\item for static class member access:
\preverbnegspace
\begin{Verbatim}
  @NonNull Map.Entry mapEntry;
\end{Verbatim}

\end{itemize}


\subsection{Uses for annotations on types\label{type-annotation-use-cases}}

This section gives examples of annotations that a programmer may wish to
place on a type.
Each of these uses is either impossible or extremely inconvenient in the
absence of the new locations for annotations proposed in this document.
For brevity, we do not give examples of uses for every type annotation.
The specific annotation names used in this
section, such as \code{@NonNull}, are examples only; this document does not
define any annotations, merely specifying where they can appear in Java
code.


% This paragraph is out of place; where should it go?
It is worthwhile to permit annotations on all uses of types (even those for
which no immediate use is apparent) for consistency, expressiveness, and
support of unforeseen future uses.
%
An annotation need not utilize every
possible annotation location.  For example, a system that fully specifies
type qualifiers in signatures but infers them for implementations~\cite{GreenfieldboyceF2005}
may not need annotations on typecasts, object creation, local variables, or
certain other locations.  Other
systems may forbid top-level (non-type-argument, non-array) annotations
on object creation (\code{new}) expressions, such as \code{new @Interned
  Object()}.
% However, the annotation system proposed here is expressive
% enough to handle arbitrary type qualifiers.


\paragraph{Generics and arrays\label{generics-and-arrays}}
% Annotations on generic type arguments and arrays are necessary so the
% programmer can fully specify types.
Generic collection classes are
declared one level at a time, so it is easy to annotate each level
individually.

It is desirable that the syntax for arrays be equally expressive.
% , for
% uniformity with generics, and for the same reasons that annotations on
% generic type arguments are useful.
Here are examples of uses for annotations on array levels:
\begin{itemize}
\item
  The Titanium~\cite{YelickSPMLKHGGCA1998} dialect of Java requires the
  ability to place the
  \code{local} annotation (indicating that a memory reference in a parallel
  system refers to data on the same processor) on various levels of an
  array, not just at the top level.
\item
  In a dependent type system~\cite{PfenningF:deptlp,Xi1998,Xi-Pfenning99},
  one wishes to specify the dimensions of an
  array type, such as \code{Object @Length(3) [] @Length(10) []} for a
  3$\times$10 array.
\item
  An immutability type system, as discussed in Section~\ref{type-qualifier-examples},
  needs to be able to specify which levels of
  an array may be modified.  Consider specifying a procedure that inverts a
  matrix in place.  The procedure parameter type should guarantee that the procedure
  does not change the shape of the array (does not replace any of the rows
  with another row of a different length), but must permit changing
  elements of the inner arrays.  In other words, the top-level array is
  immutable, the inner arrays are mutable, and their elements
  are immutable.
\item
  An ownership domain system~\cite{AbiAntounA2006:OOPSLA} uses array
  annotations to indicate properties of array parameters, similarly to type
  parameters.
\item
  \newcommand{\bs}{\char"5C}
  The ability to specify the nullness of the array and its elements
  separately is so important that JML~\cite{LeavensBR2006:JML} includes
  special syntax \code{\bs nonnullelements(a)} for a possibly-null array
  \code{a} with non-null elements.

  A simple example is a method that accepts a list of files to search.
  \code{null} may be used to indicate that there were no files to search,
  but when a list is provided, then the \code{File}s themselves must be
  non-null.  Using JSR 308, a programmer would declare the parameter as
  \code{@NonNull File @Nullable [] filesToSearch} --- more concisely,
  depending on the default nullness, as either \code{File @Nullable []
    filesToSearch} or \code{@NonNull File [] filesToSearch}

%% Examples from Eclipse's Parser (org.eclipse.jdt.internal.compiler.parser):
%     protected ASTNode[] astStack = new ASTNode[AstStackIncrement];
%     protected Expression[] expressionStack = new
%     Expression[ExpressionStackIncrement];
%     protected ASTNode[] genericsStack = new ASTNode[GenericsStackIncrement];
%     protected char[][] identifierStack;
%     this.identifierStack = new char[30][];
% These are all created with a certain size with all elements as null, but 
% the references to the stacks themselves are never null.


%% Examples, from a simple grep for "array.*or null" in the HTML Javadoc.
%% (There must be many more than the ones matching that simple search!)
%% I omitted examples places where the array elements may be null, and also
%% where they are of non-null type, such as primitive arrays.
% java.security.CodeSource.getCertificates
% java.security.CodeSource.getCodeSigners
% java.nio.charset.Charset constructor
% javax.imageio.spi.ImageReaderWriterSpi constructor
% javax.imageio.spi.ImageReaderWriterSpi.getFileSuffixes
% javax.imageio.spi.ImageReaderWriterSpi.getMIMETypes
% javax.imageio.spi.ImageReaderWriterSpi.getExtraStreamMetadataFormatNames
% javax.imageio.spi.ImageReaderWriterSpi.getExtraImageMetadataFormatNames
% javax.net.ssl.SSLParameters.getCipherSuites
% javax.net.ssl.SSLParameters.setCipherSuites
% javax.net.ssl.SSLParameters.getProtocols
% javax.net.ssl.SSLParameters.setProtocols
% javax.net.ssl.SSLParameters constructors
% javax.net.ssl.X509KeyManager.getClientAliases
% javax.net.ssl.X509KeyManager.chooseClientAlias
% javax.net.ssl.X509KeyManager.getServerAliases
% javax.net.ssl.X509KeyManager.chooseServerAlias
% javax.net.ssl.X509KeyManager.getCertificateChain
% javax.imageio.metadata.IIOMetadataFormatImpl.getChildNames
% javax.imageio.metadata.IIOMetadataFormat.getChildNames

  The opposite example, of a non-null array with nullable elements, is
  typical of fields in which, when an array element is no longer
  relevant, it is set to null to permit garbage collection.

%% I don't see how this point belongs in this list.
\item
  In a type system for preventing null pointer errors, using a default of
  non-null, and explicitly annotating references that may be null, results
  in the fewest annotations and least user
  burden~\cite{FahndrichL2003,ChalinJ2007,PapiACPE2008}.  Array elements
  can often be null (both due to initialization, and for other reasons),
  necessitating annotations on them.
\end{itemize}


\paragraph{Receivers\label{receivers}}
A type qualifier on a formal parameter is a contract regarding what the
method may (or may not) do with that parameter.  Since the method receiver
(\code{this}) is an implicit formal parameter, programmers should be able
to express type qualifiers on it, for consistency and expressiveness.  An
annotation on the receiver is a contract regarding what the method may
(or may not) do with its receiver.


% (In Java's syntax, the receiver's type is implicit rather than explicitly
% written in the source code of the method.)

For example, consider the following method:

\begin{Verbatim}
package javax.xml.bind;
class Marshaller {
  void marshal(@Readonly Object jaxbElement,
               @Mutable Writer writer) @Readonly {
    ...
  }
}
\end{Verbatim}

\noindent
The annotations indicate that \code{marshal} modifies its second parameter
but does not modify its first parameter nor its receiver.

A receiver annotation is different than a class annotation, a method
annotation, or a return value annotation:
\begin{itemize}
\item
  There may be different receiver annotations on different methods that
  cannot be factored out into the containing class.

\item
  Stating that a method does not modify its receiver is different than
  saying the method has no side effects at all, so it is not appropriate as
  a method annotation (such as JML's \code{pure}
  annotation~\cite{LeavensBR2006:JML}).

\item
  A receiver annotation is also distinct from a return value
  annotation:  a method might modify its receiver but return an immutable
  object, or might not modify its receiver but return a mutable object.
\end{itemize}

% As another example, this receiver annotation
% 
% \begin{Verbatim}
%   Dimension getSize() @Readonly { ... }
% \end{Verbatim}
% 
% indicates that \code{getSize} does not modify its receiver.

\noindent
Since a receiver annotation is distinct from other
annotations, new syntax is required for the receiver annotation.  The syntax
is adopted from C++, just as the overall syntax of Java was.
This syntax is cleaner than creating a parallel annotation, such as
\code{@ReadonlyReceiver}, for each type annotation, and is also cleaner
than changing the definition of annotations to permit writing the similar
\code{@Receiver(@Readonly)}.

% In Joe Darcy's words, this is a syntactic problem, so a syntactic
% solution like a new location for receiver annotations is cleaner than a
% non-syntactic solution.

As with Java's annotations on formal parameters, annotations on the
receiver do not affect the Java signature,
compile-time resolution of overloading, or run-time resolution of
overriding.  The Java type of every receiver in a class is the same --- but
their annotations, and thus their qualified type in a type qualifier
framework, may differ.

Some people question the need for receiver annotations.  In
case studies~\cite{PapiACPE2008}, every type system required some
receiver annotations.  Even the Nullness type system required them to
express whether the receiver was fully initialized (only in a
fully-initialized object can fields be guaranteed to be non-null).
So, the real question is how to express receiver annotations, not
whether they should exist.


\paragraph{Casts}
There are two distinct reasons to annotate the type in a type cast:  to
fully specify the casted type (including annotations that are retained
without change), or to indicate
an application-specific invariant that is beyond the reasoning capability
of the Java type system.
Because a user can apply a type cast to any expression, a user can
annotate the type of any expression.  (This is different than annotating
the expression itself; see Section~\ref{expression-annotations}.)

\begin{enumerate}
\item
Annotations on type casts permit the type in a type cast to be fully
specified, including any appropriate annotations.  In this case, the
annotation on the cast is the same as the annotation on the type of the
operand expression.  The annotations are preserved, not changed, by the
cast, and the annotation serves as a reminder of the type of the cast
expression.  For example, in

\begin{Verbatim}
  @Readonly Object x;
  ... (@Readonly Date) x ...
\end{Verbatim}

\noindent
the cast preserves the annotation part of the type and changes only the
Java type.  If a cast could not be annotated, then a cast would remove the
annotation:

\begin{Verbatim}
  @Readonly Object x;
  ... (Date) x ...       // annotation processor issues warning due to casting away @Readonly
\end{Verbatim}

This cast changes the annotation; it uses \code{x} as a
non-\code{@Readonly} object, which changes its type and would require a
run-time mechanism to enforce type safety.


An annotation processor could permit the unannotated cast syntax but
implicitly add the annotation, treating the cast type as \code{@Readonly
  Date}.  This has the advantage of brevity, but the disadvantage of being
less explicit and of interfering somewhat with the second use of cast
annotations.  Experience will indicate which design is better in practice.


% In some cases, it is safe to change the annotation part of the type when
% that is guaranteed to be safe --- for instance, casting from
% non-\code{@Readonly} to @Readonly --- but since a non-\code{@Readonly}
% expression can always be used in a @Readonly context, and overloading
% cannot be performed based on annotations alone, such a cast is never
% strictly necessary.


\item
A second use for annotations on type casts is --- like ordinary Java casts
--- to provide the compiler with information that is beyond the ability of
its typing rules.  Such properties are often called ``application
invariants'', since they are facts guaranteed by the logic of the
application program.

As a trivial example, the following cast changes the annotation but is
guaranteed to be safe at run time:

\begin{Verbatim}
  final Object x = new Object();
  ... (@NonNull Object) x ...
\end{Verbatim}

An annotation processing tool could trust such type casts, perhaps issuing
a warning to remind users to verify their safety by hand or in some other
manner.  An alternative approach would be to check the type cast
dynamically, as Java casts are, but we do not endorse such an approach,
because annotations are not intended to change the run-time behavior of a
Java program and because there is not generally a run-time representation
of the annotations.

%   (For example, annotations, like return values, are not part
% of the Java signature, so they do not affect compile-time resolution of
% overloading nor run-time resolution of overriding.)

\end{enumerate}


\paragraph{Type tests}
Annotations on type tests (\code{instanceof}) allow the programmer to
specify the full type, as in the first justification for annotations on
type casts, above.  However, the annotation is not tested at run time ---
the JVM only checks the base Java type.
In the
% preferred
implementation, there is no run-time representation of the annotations on
an object's type, so dynamic type test cannot determine whether an
annotation is present.  This abides by the intention of the Java annotation
designers, that annotations should not change the run-time behavior of a
Java program.

Annotation of the type test permits the idiom

\ifhevea
\begin{Verbatim}
  if (x instanceof MyType) {
    ... (MyType) x ...
  }
\end{Verbatim}
\else
\begin{Verbatim}[commandchars=\\\[\]]
  if (x instanceof \emph[MyType]) {
    ... (\emph[MyType]) x ...
  }
\end{Verbatim}
\fi

\noindent
to be used with the same annotated type \emph{\code{T}} in both
occurrences.  By contrast, using different types in the type test and the
type cast might be confusing.

To prevent confusion caused by incompatible annotations, an annotation
processor could require the annotation parts of the operand and the type to
be the same:

\begin{Verbatim}
  @Readonly Object x;
  if (x instanceof Date) { ... }            // error: incompatible annotations
  if (x instanceof @Readonly Date) { ... }  // OK
  Object y;
  if (y instanceof Date) { ... }            // OK
  if (y instanceof @NonNull Date) { ... }   // error: incompatible annotations
\end{Verbatim}

(As with type casts, an annotation processor could implicitly add a
missing annotation; this would be more concise but less explicit, and
experience will dictate which is better for users.)

As a consequence of the fact that the annotation is not checked at run
time, in the following
\begin{Verbatim}
  if (x instanceof @A1 T) { ... }
  else if (x instanceof @A2 T) { ... }
\end{Verbatim}
the second conditional is always dead code.  An annotation processor may
warn that one or both of the \code{instanceof} tests is a compile-time type
error.

% javac does not warn about dead code in
%   if (x instanceof Object) { ... }
%   else if (x instanceof Object) { ... }


A non-null qualifier is a special case because it is possible to check at
run time whether a given value can have a non-null type.  A type-checker for
a non-null type system could take advantage of this fact, for instance to
perform flow-sensitive type analysis in the presence of a \code{x != null}
test, but JSR 308 makes no special allowance for it.


\paragraph{Object creation}
Java's \code{new} operator indicates the type of the object being created.
As with other Java syntax, programmers should be able to indicate the full
type, even if in some cases (part of) the type can be inferred.
In some cases, the annotation cannot be inferred; for instance, it is
impossible to tell whether a particular object is intended to be mutated
later in the program or not, and thus whether it should have a
\code{@Mutable} or \code{@Immutable} annotation.
Annotations on object creation expressions could also be statically verified
(at compile time) to be compatible with the annotations on the constructor.

% Such annotations could optionally disambiguate among multiple
% constructors --- for example, a \code{@Readonly} version might choose a
% code path that performs no side effects.

\paragraph{Type bounds}
Annotations on type parameter bounds (\code{extends})
and wildcard bounds (\code{extends} and \code{super})
allow the programmer to fully constrain generic types.  Creation of
objects with constrained generic types could be statically verified to
comply with the annotated bounds.

\paragraph{Inheritance}
Annotations on class inheritance (\code{extends} and
\code{implements}) are necessary to allow a programmer to fully
specify a supertype. It would otherwise be impossible to extend the
annotated version of a particular type $t$ (which is often a valid
subtype or supertype of $t$) without using an anonymous class.

\noindent
\label{class-inheritance-annotations}
These annotations also provide a convenient way to alias otherwise
cumbersome types. For instance, a programmer might declare

\begin{Verbatim}
  final class MyStringMap extends
    @Readonly Map<@NonNull String, @NonEmpty List<@NonNull @Readonly String>> {}
\end{Verbatim}

\noindent
so that \code{MyStringMap} may be used in place of the full,
unpalatable supertype.  (However, also see Section~\ref{typedef} for
problems with this approach.)

\paragraph{Throws clauses}
Annotations in the \code{throws} clauses of method declarations allow
programmers to enhance exception types. For instance, programs that
use the \code{@Critical} annotation from the above examples could be
statically checked to ensure that \code{catch} blocks that can catch a
\code{@Critical} exceptions are not empty.

% Actually, the JLS3 grammar for CatchClause refers to FormalParameter,
% which is not itself defined, so maybe special syntax is needed,
% depending on how that error is fixed.

There is no need for special syntax to permit annotations on the type of a
caught exception, as in

\begin{Verbatim}
  catch (@NonCritical Exception e) { ... }
\end{Verbatim}

\noindent
In this example case, a tool could warn if any \<@Critical> exception can
reach the \<catch> clause.


% \subsection{Target meta-annotation for type annotations}
% \label{target-meta-annotation}
% 
% 
% 
% 
% The remainder of this section provides background on the \code{Target}
% meta-annotation.
% 
% Java's \code{Target} meta-annotation provides machine-readable
% documentation of the intended use of an annotation.  For example, the
% \code{@Override} annotation is intended for use only on method
% declarations, so its definition is written as
% 
% \begin{Verbatim}
%   @Target(ElementType.METHOD)
%   public @interface Override { }
% \end{Verbatim}
% 
% 
% Java SE 6 requires the compiler to issue an error if a programmer places an
% annotation in a location not permitted by its Target meta-annotation.
% % Thus, it is already the case that examination of the
% % source alone does not indicate whether the annotation will be rejected by
% % the compiler.
% 
% \begin{Verbatim}[commandchars=\|\[\]]
%   @Override                                     // compile-time error
%   class Window extends Container {
%     @Override String warningString;             // compile-time error
%     @Override Container getContainer() { ... }  // OK; correct use of @Override
% \end{Verbatim}



\subsection{Syntax of array annotations\label{array-syntax}}

As discussed in Section~\ref{type-annotation-use-cases}, it is
desirable to be able to independently annotate both the base type and
each distinct level of a nested array.
Forbidding annotations on arbitrary levels of an array would simplify the
syntax, but it would reduce expressiveness to an unacceptable degree.
The syntax of array annotations follows the same general prefix rule as
other annotations, though it looks slightly different because the syntax
of array types is different than the syntax of other Java types.
(Arrays are less commonly used than generics, so even if you don't like the
array syntax, it need not bother you in most cases.)

Most programmers read the Java type \code{String[][]} as
``array of arrays of Strings''.  Analogously, the construct
\code{new String[2][5]} is ``new length-2 array of length-5 array of Strings''.
After \code{a = new String[2][5]}, \code{a} is an array with
2 elements, and \code{a[1]} is a 5-element array.

In other words, the order of reading an array type is left-to-right for the
brackets, \emph{then} left-to-right for the base type.

\begin{Verbatim}
  type:                       String             []            []

  order of reading:  2------------->  1 ------------------------>
\end{Verbatim}

% Even Josh Bloch got this wrong when I gave it to him as a Java Puzzler of
% my own (he thought you would read from right to left), so it's
% understandable if you didn't realize that this is how Java arrays have
% always worked.


To more fully describe the 2x5 array, a programmer could use the
type ``length-2 array of length-5 array of Strings'':

\begin{Verbatim}
  type:                       String  @Length(2) [] @Length(5) []

  order of reading:  2------------->  1 ------------------------>
\end{Verbatim}

The prefix notation is natural, because the type is read in exactly
the same order as any Java array type.  As another example, to express
``non-null array of length-10 arrays of English Strings'' a programmer
would write

\begin{Verbatim}
  type:              @English String  @NonNull [] @Length(10) []

  order of reading:  2------------->  1 ----------------------->
\end{Verbatim}


% The prefix notation doesn't really work for people who read the original
% declaration by starting with the base type and then working
% \emph{right-to-left}, as ``String array array''.


An important property of this syntax is that adding array levels does not
change the meaning of existing annotations.  For example, \code{var1} has
the same annotations as the elements of \code{arr2}:

\begin{Verbatim}
  @NonNull String var1;
  @NonNull String[] arr2;
\end{Verbatim}

\noindent
because in each case \code{@NonNull} refers to the String, not the array.
This consistency is especially important since the two variables may appear in a single
declaration:

\begin{Verbatim}
  @NonNull String var1, arr2[];
\end{Verbatim}

%% Probably don't bring this up.  It should be possible to infer it anyway.
% In this (deprecated but legal) syntax, in each component you read
% left-to-right, like this:
% 
%     @English String @NonNull [] [] []  arr1,   arr2 @Length(10) [] [] [];
%     3-------------> 2--------------->               1------------------>


%     For example, \code{arr1} should have the same annotations
%     as the elements of \code{arr2}:
% \begin{Verbatim}
%   @A T[@B] arr1, arr2[@C];
% \end{Verbatim}

%     By contrast, it would be confusing to have a syntax in which
% \begin{Verbatim}
%   @A List<@B Object>          // @A refers to List
%   @A List<@B Object> @C []    // @A refers to array, @C refers to List
% \end{Verbatim}

A potential criticism is that a type annotation at the very beginning of a
declaration does not refer to the full type, even though declaration
annotations (which also occur at the beginning of
the declaration) do refer to the entire variable.  As an example, in
\code{@NonNull String[] arr2;} the variable \code{arr2} is not non-null.
This is actually a criticism of Java itself, not of the JSR 308
annotation extension, which is merely consistent with Java.  In a
declaration \code{String[] arr2;}, the top-level type constructor does not
appear on the far left.  An annotation on the whole type (the array) should
appear on the syntax that indicates the array --- that is, on the brackets.


Other array syntaxes can be imagined, but they are less consistent with
Java syntax and therefore harder to read and write.
Examples include
making annotations at the beginning of the type refer to the whole type,
using a postfix syntax rather than a prefix syntax, and postfix syntax
within angle brackets as for generics.

% The IGJ type system~\cite{ZibinPAAKE2007} has been implemented using both a
% generics-like syntax and also the JSR 308 annotation syntax.  In a case
% study, a programmer preferred the JSR 308 syntax to the generics-like
% syntax~\cite{ZibinPAAKE2007}.


\subsection{Disambiguating type and declaration annotations\label{disambiguating}}

An annotation before a method declaration annotates either the return type,
or the method declaration.  There is never any ambiguity regarding the
programmer intention:  in that location, a type annotation annotates the
return type, and a declaration annotation annotates the method itself.  The
\code{@Target} meta-annotation indicates whether an annotation is a type
annotation.  Field declarations are treated similarly.


% This reuse of the annotation location means that there is no need for new
% syntax for annotations on types in declarations.

Suppose that we have these annotation declarations:
\begin{Verbatim}
  @Target(ElementType.TYPE_USE)
  @interface NonNegative { }

  @Target(ElementType.METHOD)
  @interface Override { }

  @Target(ElementType.FIELD)
  @interface GuardedBy { ... }
\end{Verbatim}
Then, in
\begin{Verbatim}
  @Override
  @NonNegative int getHeight() { ... }
\end{Verbatim}
\code{@Override} applies to the method and \code{@NonNegative} applies
to the return type.
Furthermore, in these two field declarations
\begin{Verbatim}
  @NonNegative int balance;
  @GuardedBy("myLock") long lastAccessedTime;
\end{Verbatim}
the annotation \code{@NonNegative} applies to the field type \code{int},
not to the whole variable declaration nor to the variable \code{balance}
itself.  The annotation \code{@GuardedBy("accessLock")} applies to the
field \code{lastAccessedTime}.

Here are a few facts that follow from the specification.  For brevity, we
use ``type annotation'' as shorthand for ``an annotation that is
meta-annotated with \code{@Target(ElementType.TYPE\_USE)}''.
\begin{itemize}
\item
  A type annotation need not also be meta-annotated with the targets
  \code{ElementType.TYPE}, \code{ElementType.METHOD}, or
  \code{ElementType.FIELD} in order to be applied to a class, a method
  return type, or a field type --- and it generally should \emph{not}
  contain such a \code{@Target} meta-annotation.
\item
  A type annotation may not appear before a void method (a method with no
  return type).  This also follows from the fact that \code{void} is not a
  type.
\item
  A type annotation may not appear on a package (a package declaration does
  not contain a use of a type).
\item
  A type annotation may appear before a constructor, in which case it
  represents the object that the constructor is creating.
\item
  As with any other non-static method, a type annotation may
  appear on the receiver of an inner class constructor.
\end{itemize}


Strictly speaking, a \code{@Target} meta-annotation could indicate that an
annotation is \emph{both} a type annotation and a declaration annotation.  In
such a case, the annotation would apply to both the return type and the
method declaration, and it would exist twice in the class file.  We have
not found an example where that is desirable; although it is legal, it is
considered bad style.


When an annotation has no \code{@Target} meta-annotation (which is bad
style!), it is treated as if it applies to all locations.
%
For example, if the \code{@Foo} annotation definition lacks a
\code{@Target} meta-annotation, then in this code:

\begin{Verbatim}
  @Foo int m() { return 0; }
\end{Verbatim}

\noindent
the \code{@Foo} annotation applies to both the \code{m} method, and the
\code{int} data type.  (If it is not intended as a type annotation, it will
be ignored by any type annotation processor, so it does no harm on the
\code{int} data type.)  The \code{@Foo} annotation appears twice in the AST
during annotation processing, and it appears twice in the classfile.
% In other words, a Java 6 and a Java 7 compiler would
% produce classfiles with different numbers of annotations.
A tool that reads a classfile and writes Java-like output, such as Javadoc
or a decompiler, must take care not to write an annotation twice in the
decompiled code, as in ``\code{@Foo @Foo int m()}\ldots''.
This requirement does
not add extra work when constructing the tool, since the tool has to handle
the case where the \<@Target> annotation explicitly included both
\<ElementType.METHOD> and \<ElementType.TYPE\_USE>.


In summary:  for certain syntactic locations, which target (Java construct)
is being annotated depends on the annotation.
There is no ambiguity for the compiler:
the compiler applies the annotation to every
target that is consistent with its meta-annotation (see
Section~\ref{target-meta-annotation}).
In practice, programmers
have no difficulty in understanding where a given annotation applies.


% Alternative syntaxes for receiver annotations:
%  new syntactic location <-- our choice
%  @ReceiverNonNull      <-- it's ugly to duplicate every annotation definition
%  @ @NonNull Receiver   <-- this is legal (!), but ugly & maybe shouldn't be legal
%  @Receiver(@NonNull)   <-- this requires arbitrary annotations as arguments to annotations



% The Target Javadocs state
%   If such a meta-annotation is present, the compiler will enforce the
%   specified usage restriction.
% (See http://java.sun.com/javase/6/docs/api/java/lang/annotation/Target.html.)





% Explain the difference between
%  * meta-annotating with TYPE.
%  * not annotating.
%  * annotating with everything (except ANNOTATION).
% Explain backward-compatibility with anything that's not meta-annotated.


% We want to avoid text like this, in the FindBugs manual:
% "When this annotation is applied to a method it applies to the method return value."
% The problem is that it's not machine-checked.
% (That text is for CheckForNull, but such text does not appear for other
% annotations such as NonNull and Nullable.)



%% IMPLEMENTATION NOTE:
% As noted in Section~\ref{target-meta-annotation},
% the order of annotations is not used to disambiguate;
% \code{@NonNull @Override Dimension getSize()} has the same
% meaning but is poor style.  (An annotation processor could warn about this
% order, just as tools warn about modifiers --- such as \code{final static}
% --- that are not written in the order recommended by Sun.)
% % The recommended order is:
% %   public protected private abstract static final transient volatile synchronized native strictfp interface


%% ALTERNATIVE DESIGN
% Different syntaxes are possible, in which declaration and type annotations
% appear in different locations in the grammar.  Such a syntax is warranted
% in two circumstances.  (1) If programmers find it confusing to determine
% which construct an annotation applies to, and the alternate syntax is
% clearer overall.  (2) If there exist annotations that can apply equally
% well to both methods and return value types (or to both types and variable
% declarations, etc.), and that have different semantics in the two
% situations.  Both circumstances are poor style.  (The only example of an
% annotation that can go on both locations that we have found is an
% annotation that is itself actually a collection of other annotations,
% such as "@MultipleAnnotations" --- which is not even possible to write
% currently, since an annotation cannot take an arbitrary other annotation
% as an argument.)  Another argument for the alternate syntax is
% that the grammar should be maximally flexible to permit unforeseen future
% uses of such annotations.  This must be traded off against readability and
% usability for important known common cases.



% The person who defines the annotation (and writes
% its annotation processor) decides whether an annotation that appears before
% the return value applies to the method declaration or to the return type.



% It is also convenient to use annotations to describe the effect of invoking
% a method, such as whether it may block, allocate memory, etc.  Such
% annotations could be placed on either the return value (as is current practice)
% or the receiver; this semantic decision is up to the person who defines the
% annotation.







\section{Discussion of tool modifications\label{mods-discussion}}

This section primarily discusses tool modifications that are consequences
of JSR 308's changes to the Java syntax and class file format, as presented
in Sections~\ref{syntax} and~\ref{class-file}.


\subsection{Compiler\label{compiler-mods}}

The syntax extensions described in Section~\ref{syntax}
require the Java compiler to accept annotations in the proposed
locations and to add them to the program's AST\@.  The relevant AST node
classes must also be modified to store these annotations.


Javac's \code{-Xprint} functionality reads a \code{.class} file and prints
the interface (class declarations with signatures of all fields and
methods).  (The \code{-Xprint} functionality is similar to javap, but
cannot provide
any information about bytecodes or method bodies, because it is implemented
internally as an annotation processor.)
This must be updated to print the extended annotations as well.
Also see Section~\ref{class-file-tools}.


Section~\ref{compiler} requires compilers to place certain annotations
in the class file.  This is consistent with the principle that annotations
should not affect behavior:  in the absence of an annotation processor, the
compiler produces the same bytecodes for annotated code as it would have
for the same code without annotations.  (The class file may differ, since
the annotations are stored in it, but the bytecode part does not differ.)

This may change the compiler implementation of certain optimizations, such
as common subexpression elimination, but this restriction on the compiler
implementation is unobjectionable for three reasons.
\begin{enumerate}
\item
Java-to-bytecode compilers rarely perform sophisticated
optimizations, since the bytecode-to-native (JIT) compiler is the major
determinant in Java program performance.  Thus, the restriction will not
affect most compilers.
% (We need a list of problematic optimizations, and a catalog of widely used
% Java-to-bytecode compilers indicating whether each one performs the
% optimizations.)
\item
The compiler workarounds are simple.  Suppose that two expressions
that are candidates for common subexpression elimination
have different type annotations.
% or statements
A compiler could:  not perform the optimization when the annotations
differ; create a single expression whose type has both of the annotations
(e.g., merging \code{(@Positive Integer) 42} and \code{(@Even Integer) 42}
into \code{(@Positive @Even Integer) 42});
or create an unannotated expression and copy its value into two variables
with differently-annotated types.
% 
\item
It seems unlikely that two identical, non-trivial expressions would
have differently-annotated types.  Thus, any compiler restrictions will
have little or no effect on most compiled programs.
% (We should try to predict or measure this number.)
\end{enumerate}



Java compilers can often produce bytecode for an earlier version of the
virtual machine, via the \code{-target} command-line option.  For example,
a programmer could execute a compilation command such as \code{javac
-source 7 -target 5 MyFile.java}.  A Java 7 compiler produces a class file
with the same attributes for type annotations as when the target is a
version 7 JVM\@.  However, the compiler is permitted to also place type
annotations in declaration attributes.  For instance, the annotation on the
top level of a return type would also be placed on the method (in the
method attribute in the class file).  This enables class file analysis
tools that are written for Java SE 5 to view a subset of the type
qualifiers (lacking generics, array levels, method receivers, etc.), albeit
attached to declarations.

A user can use a Java SE 5/6 compiler to compile a Java class that contains
type annotations, so long as the type annotations only appear in places
that are legal in Java SE 5.  Furthermore, the compiler must be provided
with a definition of the annotation that is meta-annotated not with
\code{@Target(ElementType.TYPE\_USE)} (since \code{ElementType.TYPE\_USE}
does not exist in Java SE 5/6), but with no meta-annotation or with a
meta-annotation that permits annotations on any declaration.


\subsection{ASTs and annotation processing\label{asts-and-annotation-processing}}

The Java Model AST of JSR 198 (Extension API for Integrated Development
Environments)~\cite{JSR198} gives access to the entire source code of a
method.  This AST (abstract syntax tree) must be updated to represent all
new locations for annotations.

Sun's Tree API, which exposes the AST (including annotations) to authors of
javac annotation processors (compile-time plug-ins), must be updated to
reflect the modifications made to the internal AST node classes described in
Section~\ref{syntax}.
The same goes for other Java compilers, such as that of Eclipse).


\label{jsr269-changes}

Like reflection, the JSR 269 (annotation processing) model
does not represent constructs below the
method level, such as individual statements and expressions.  Therefore, it
needs to be updated only with respect to declaration-related annotations
(the top of Figure~\ref{tbl:target_types}; also see Section~\ref{out-of-scope-annotation-processing-api}).
The JSR 269 model, \code{javax.lang.model.*},
already has some classes representing annotations; see
\myurl{http://java.sun.com/javase/6/docs/api/javax/lang/model/element/package-summary.html}.
The annotation processing API in \code{javax.annotation.processing} must
also be revised.




\subsection{Reflection\label{reflection}}

To do:  Complete this design.

The \code{java.lang.reflect.*} and \code{java.lang.Class} APIs give access
to annotations on public API elements such as classes,
method signatures, etc.  They must be updated to give the same
access to the new extended annotations in the top of
Figure~\ref{tbl:target_types}.

Here are a few examples (the design is not yet complete).

\begin{enumerate}
\item
\code{java.lang.reflect.Type} needs to implement
\code{java.lang.reflect.AnnotatedElement}.
(An alternative would be an \code{java.lang.reflect.AnnotatedType}
interface, with two methods that return an annotation and a type.  This
design seems suboptimal, because most
clients would immediately cast the result of the latter method.)

\end{enumerate}

%% This design doesn't work, as it gives access to only the top level of
%% annotations.  It's better to obtain the annotated type and query it.
% New methods \code{Method.getReceiverAnnotation} (for the
% receiver \code{this}) and \code{Method.getReturnAnnotation} (for the return
% value) would parallel the existing
% \code{Method.getParameterAnnotations} (for the formal parameters).
% \code{Method.getAnnotations} is unchanged, for reasons of backward
% compatibility:  it returns annotations on the method declaration itself.
% % Should it return annotations on the return value as well?
% 
% Suppose that a method is declared as:
% 
% \begin{Verbatim}
%   @NonEmpty List<@Interned String> foo(@NonNull List<@Opened File> files) @Readonly {...}
% \end{Verbatim}
% 
% \noindent
% Then \code{Method\-.getParameterAnnotations()} returns the \code{@NonNull}
% annotation, just as in Java SE 6.
% New method \code{Method.getReturnAnnotations()} returns the \code{@NonEmpty}
% annotation, and
% new method \code{Method.getReceiverAnnotations()} returns the
% \code{@Readonly} annotation.
% 
% There is a problem with these proposed methods:  they only give access to
% the annotation on the raw (top-level) type.  They do not give access to
% annotations on generic types in a method's signature, such as the instances
% of \code{@Interned} and \code{@Opened} above.

% Therefore, it is usually better to obtain the annotated type (say, of a
% parameter or return value) and to query it directly.


\subsubsection{Non-changes to reflection\label{non-changes-to-reflection}}

Reflection gives no access to method implementations, so no changes are
needed to
provide access to annotations on casts (or other annotations inside
a method body), type parameter names, or similar implementation details.


% This is lifted from http://blogs.sun.com/darcy/entry/so_you_want_to_change
The Mirror API \code{com.sun.mirror.*} need not be updated, as it has been
superseded by JSR 269~\cite{JSR269}.


Method \code{Method\-.getParameterAnnotations()} returns the annotations on
the parameter \emph{declarations}, just as in Java SE 6.  It does not return
type annotations.  There is no point in new methods that parallel it,
such as \code{Method.getReceiverAnnotation} (for the receiver
\code{this}) and \code{Method.getReturnAnnotation} (for the return
value).  Rather, the interface will provide a uniform mechanism for
querying annotations on types.


The semantics of reflective invocation is not changed.
(The changes described in this section are to APIs that query classes,
method signatures, etc.)
For instance, suppose that a program reflectively calls a method
with a parameter whose type is annotated as \code{@Readonly}, but the
corresponding argument has a declared type that is non-\code{@Readonly}.
The call succeeds.  This is a requirement for backward compatibility:  the
existence of annotations in the class file should not cause a standard JVM
to behave differently than if the annotations are not present (unless the
program uses reflection to explicitly examine the annotations).  Likewise,
other reflective functionality such as \code{AtomicReferenceFieldUpdater}
can bypass annotation constraints on a field.

% On the other hand, if you are using a custom version of the JVM -- which is
% appropriate in certain situations, including for testing -- then it could
% do whatever is appropriate for the particular type system.


\subsection{Virtual machine and class file analysis tools\label{class-file-tools}}

% Since load-time plug-ins
% % (described in Section~\ref{load-time}) can use
% the \code{premain} method,
No modifications to the virtual machine are necessary.
(The changes to reflection (Section~\ref{reflection}) do change virtual
machine APIs in a minor way, but the representation of execution of
bytecodes is unaffected.)

The \code{javap} disassembler must recognize the new class
file format and must output annotations.

The pack200/unpack200 tool must preserve the new attributes through a
compress-decompress cycle.
% http://java.sun.com/javase/6/docs/api/java/util/jar/Pack200.html


The compiler and other tools that read class files are trivially compatible
with class files produced by a Java SE 5/6 compiler.  However, the tools
would not be able to read the impoverished version of type qualifiers that
is expressible in Java SE 5 (see Section~\ref{compiler-mods}).  It is
desirable for class file tools to be able to read at least that subset of
type qualifiers.  Therefore, APIs for reading annotations from a class file
should be dependent on the class file version (as a number of APIs already
are).  If the class file version indicates Java SE 5 or 6, and none of the
extended annotations defined by JSR 308 appear in the class file, then the
API may return (all) annotations from declarations when queried for the
annotations on the top-level type associated with the declaration (for
example, the top-level return type, for a method declaration).


\subsection{Other tools\label{other-tools}}

Javadoc must output annotations at the new locations when those are part
of the public API, such as in a
method signature.
%% (Does the doclet API itself need to change??

% This is true but irrelevant: "(if meta-annotated with \code{@Documented})"
% http://java.sun.com/javase/6/docs/api/java/lang/annotation/Documented.html
% @Documented annotations "are part of the public API of the annotated
% elements", and "are documented by javadoc and similar tools by default".
% (No option exists at present in the standard doclet to override that default.)

Similar modifications need to be made to tools outside the Sun JDK,
such as IDEs (Eclipse, IDEA, JBuilder, jEdit, NetBeans), other tools that
manipulate Java code (grammars for CUP, javacc), and tools that
manipulate class files (ASM, BCEL\@).  These changes need to be made by the
authors of the respective tools.
% Eugene Kuleshov has volunteered to make the ASM updates.
% (\myurl{http://asm.objectweb.org/})
% (One example in ASM:  \code{util.TraceClassVisitor} prints annotations and
% must be extended to print the new annotations.)


A separate document, ``Custom type qualifiers via annotations on Java
types'' (\myurl{http://types.cs.washington.edu/jsr308/java-type-qualifiers.pdf}),
explores implementation strategies for annotation processors that act as type-checking
compiler plug-ins.  It is not germane to this proposal, both because this proposal
does not concern itself with annotation semantics and because writing such
plug-ins does not require any changes beyond those described in this document.


A separate document, ``Annotation File Specification''
(\myurl{http://types.cs.washington.edu/annotation-file-utilities/annotation-file-format.pdf}), describes a
textual format for annotations that is independent of \code{.java} or
\code{.class} files.  This textual format can represent annotations for
libraries that cannot or should not be modified.  We have built
tools for manipulating annotations, including extracting
annotations from and inserting annotations in \code{.java} and
\code{.class} files.
% Such tools will be useful in transitioning to use of the new annotations.
That file format is not part of this proposal for
extending Java's annotations; it is better viewed as an implementation
detail of our tools.


%% TO DO

% \subsection{Java Language Specification}
% 
% The Java Language Specification needs to be updated.  A separate document
% will one day contain a list of all the changes.  (The list of changes would
% be too long to include in this document, and would not succinctly convey
% the implications of the changes.)  Finding all the places that mention
% annotations is a good start.
% 
% One nonobvious place is in places like section~9.6.1.5, where the
% description of \code{SuppressWarnings} states
% ``If a program declaration is annotated \ldots''
% and the use of ``declaration'' must be changed to ``element'' or
% ``construct'' or some similar word.
% 
% 
% \subsection{Java Virtual Machine Specification}
% 
% The Java Virtual Machine Specification (JVMS) needs to be updated to
% describe the \code{Runtime\{Inv,V\}isibleType\-Annotations} attributes.
% This section, or a separate document, will one day contain a list of all
% the changes.  Since the third edition of JVMS~\cite{LindholmY:JVMS3} has
% not yet been published, the changes must work from the document titled
% ``revisions to `The class file Format'\,'', which this document calls
% ``JVMS3'' and is available at
% \myurl{http://java.sun.com/docs/books/jvms/second_edition/ClassFileFormat-Java5.pdf}.


\section{Other possible extensions to Java annotations\label{other-annotations}}

The Type Annotations (JSR 308) specification may be extended in the future,
both to improve the specification and also to add new material.
Any improvement to Java's annotation system is within bounds.  The JSR is
titled ``Type Annotations'' to avoid a vague and inelegant title such as
``Extensions to Java's annotation system'', and because the initial
extensions enable annotations on types.  However, non-type-related
improvements to annotations are within scope and will be considered.  This
is especially true if the additional changes are small, there is no better
venue to add such an annotation, and the new syntax would permit
unanticipated future uses.

This section gives examples of further extensions to Java's annotation
system that may be considered, either for JSR 308 or in the future.
Inclusion here is not an endorsement; this list is intended to be a
resource for current and future language designers, explaining pros and
cons of possible changes.
If you care enough about one of these extensions, please
volunteer to be the point person for the work.  That could make them a
reality.

Java has a massive worldwide user base, so the bar to modifying the Java
language is quite high.  Any proposed modification requires both compelling
use cases (for many users, not just a niche community) that are currently
impossible, and it requires a convincing demonstration (not just a claim)
that there are no negative consequences, such as undesirable interactions
with current language features or tools.  Where possible, this section
gives a brief discussion of benefits and potential problems as a starting
point.  (Problems that potentially apply to all extensions, such as
existing code that reflects over annotations encountering unexpected
structures, are not repeated for each extension.)


\paragraph{Not the last annotations JSR.}
It is \emph{not} a goal that JSR 308 is the last annotation-related JSR\@.
JSR 308 may leave some issues to future language designers, just as
JSR 175 (the previous annotations JSR~\cite{JSR175}) did.
Leaving issues unresolved is preferable to making hasty decisions, or
decisions with unknown technical implications.
By contrast, it \emph{is} a goal of JSR 308 not to unnecessarily close off
realistic future avenues of extension.



\subsection{Duplicate (multiple, repeated) annotations at a location\label{duplicate-annotations}}

% This is in desperate need of good motivation; right now it is completely
% lacking.

It may be desirable for some
% (but not all)
annotations to be
specified more than once at a single location.
Currently, this is impossible: ``It is a compile-time
error if a declaration is annotated with more than one annotation for a
given annotation type''~\cite[\S9.7]{GoslingJSB2005}.
(By contrast, C\# supports duplicate annotations on a given program element.)

As a related motivation, array-valued annotations can be clumsy to write:

\begin{Verbatim}
  @Resources({
      @Resource(name = "db1", type = DataSource.class)
      @Resource(name = "db2", type = DataSource.class)
  })
  public class MyClass { ... }
\end{Verbatim}

A cleaner syntax is desirable for both purposes:

\begin{Verbatim}
  @Resource(name = "db1", type = DataSource.class)
  @Resource(name = "db2", type = DataSource.class)
  public class MyClass { ... }
\end{Verbatim}

We note two possible approaches to this problem:  desugaring into arrays,
or adding a \<getAnnotations> method to two interfaces.
Among the two proposals, the second is cleaner, more elegant, and easier
for clients to use.  However, it requires either changing existing
interfaces or creating new ones.

For backward compatibility, in both approaches an annotation may be
repeated only if its definition is meta-annotated with \code{@Repeatable}:

\begin{Verbatim} 
  public @interface Repeatable {
    public boolean value() = true;
  }
\end{Verbatim}

\noindent
In the below, assume that the definitions of \<A> and \<B> are
meta-annotated with \<@Repeatable>.

% \noindent
% For annotations not so meta-annotated, the compiler throws an
% error/warning just as for Java SE 6.


It is already possible in Java SE 6 for a location to have both an
inherited and an explicit annotation of the same type.  The 
\code{@Inherited} meta-annotation specification states that a
\code{getAnnotation}[\code{s}] query returns only the
explicit annotation.  This requirement should perhaps be relaxed, even if
inheritance among annotations (Section~\ref{inheritance-among-annotations})
is not permitted.  For some annotation
processors, it is best to check that the explicit annotation is consistent
with the overridden, inherited one and possibly merge information in the
two annotations.  The current design makes that inconvenient to do.


\subsubsection{Desugar into wrapper annotations\label{duplicate-annotations-desugar}}

% Joe Darcy and Danny Coward have volunteered (in 2006 or 2007) to produce
% a proposal on this, but they have been foot-dragging since early 2007,
% and so I have given up on nagging and waiting.
Desugar duplicate annotations into
the current array syntax.  For instance, desugar

\begin{Verbatim}
  @A(1) @B @A(2) Object x;
\end{Verbatim}

\noindent
into

\begin{Verbatim}
  @AContainer({@A(1), @A(2)}) @B Object x;
\end{Verbatim}

This approach treats duplicate annotations as purely a syntactic
convenience; it does not change annotations in any deep way.  This approach
is compatible with certain existing J2EE annotation processors that are
already written to process both \code{@A} and \code{@AContainer}.

This proposal would need to specify what happens if only one \code{@A}
annotation is present.  Most likely, the desugaring
would still place \code{@A} into a singleton \code{@AContainer} annotation.
Otherwise, client code would become more complicated, since it would have
to deal with the possibility of either an \code{@A} annotation or an
\code{@AContainer} annotation.

This proposal would need to specify what happens if both \code{@A} and
\code{@AContainer} annotations are present.  Most likely, the desugaring
would insert \code{@A} into the existing \code{@AContainer} annotation,
either at the front or the back depending on whether the \<@A> or
\<@AContainer> annotation came first.
Otherwise, client code would become more complicated, since it would have
to deal with the possibility of both an \code{@A} annotation or an
\code{@AContainer} annotation, and with handling the relative order.

This proposal would need to specify what happens if the user queries for
annotation \code{@A}:  would that always throw an exception (probably the
best choice), or succeed if one \code{@A} annotation is present, or succeed
if an \code{@AContainer} annotation with a length-1 array is present, or
return the first \code{@A} annotation?

One problem with this proposal is that it loses the ordering of
differently-named annotations (even if the ordering of same-named
annotations is preserved within the container).  For example, it cannot
distinguish these
declarations:
\begin{Verbatim}
  @A(1) @B @A(2) Object x;
  @A(1) @A(2) @B Object x;
\end{Verbatim}

Another problem is that it requires defining an \code{@AContainer}
annotation for each annotation \code{@A}, or else annotation \code{@A}
cannot be duplicated.  It would be better not to burden programmers with
writing and maintaining this boilerplate code.

Another problem with this proposal is that it makes other possible
extensions to annotations, such as inheritance among annotations
(Section~\ref{inheritance-among-annotations}), more difficult and clumsy to
implement and use.  JSR 308 should aim to preserve, not to preclude, future
avenues of extension (see Section~\ref{other-annotations}).


%% More details from Joe Darcy, but I don't see that they add much to the
%% shorter description above.
% A new meta-annotation is introduced to allow an annotation type
% to declare what its containing type should be:
% 
% @interface Container {
%   Class<? extends Annotation> value();
% }
% 
% so that the declaration
% 
% @Container(MyRepeatedAnnotationContainer.class)
% @interface MyAnnotation()
% 
% would allow something like
% 
% @MyAnnotation(1) @MyAnnotation(2) @MyAnnotation(3)
% public class Foo();
% 
% to be treated as
% 
% @MyRepeatedAnnotationContainer(
%   {@MyAnnotation(1),
%    @MyAnnotation(2),
%    @MyAnnotation(3)})
% public class Foo();
% 
% (I'm not sure what the exact syntactic sugar should be; it might be
% beneficial to wrap the repeated annotations in "@{", "}" to emphasize
% the grouping or to restrict the repeated annotations to be sequentially
% applied.)
% 
% Declaring the container in the annotation type provides the compiler and
% the runtime the information needed to construct or lookup the containing
% type.  There could be a new method on AnnotatedElement like
% 
% <T extends Annotation> T[] getRepeatedAnnotation(Class<T> annotationClass)
% 
% or
% 
% <T extends Annotation> List<T> getRepeatedAnnotation(Class<T>
% annotationClass)
% 
% This method could potentially handle some of the tricky cases like
% returning the non-contained annotation if there is one, otherwise return
% the contained annotation, etc.
% 
% The intention is to allow the @Container meta-annotation to be
% retrofitted to existing wrapper annotations.


\subsubsection{Add new \<getAnnotations> method\label{duplicate-annotations-getAnnotations}}

Add a new \<getAnnotations> method, which returns multiple annotations,
to two interfaces: \code{java.lang.reflect.AnnotatedElement} and
\code{javax.lang.model.element.Element}.

\begin{enumerate}

\item
Create a new method

\begin{Verbatim}
  <T extends Annotation> T[] getAnnotations(Class<T> annotationClass)
\end{Verbatim}

% This method returns an array and not a List for consistency with existing
% methods getAnnotations and getDeclaredAnnotations.

\noindent
that returns all annotations for the specified annotation type that are
present on the receiver element.  As with \code{getDeclaredAnnotations},
the return value is never null but may have zero length.

\item
Slightly modify the specification of the existing method

\begin{Verbatim}
  <T extends Annotation> T getAnnotation(Class<T> annotationClass)
\end{Verbatim}

\noindent
When duplicate annotations exist, method \code{getAnnotation} could either
give the first one (convenient for backward compatibility) or throw an
exception (convenient to prevent erroneous processing).  The latter seems
like a better choice.

% Classes:
%   java.lang.Class.getAnnotation(java.lang.Class)
%   java.lang.Package.getAnnotation(java.lang.Class)
%   java.lang.reflect.AccessibleObject.getAnnotation(java.lang.Class)
%   java.lang.reflect.Constructor.getAnnotation(java.lang.Class)
%   java.lang.reflect.Field.getAnnotation(java.lang.Class)
%   java.lang.reflect.Method.getAnnotation(java.lang.Class)
% Interfaces:
%   java.lang.reflect.AnnotatedElement.getAnnotation(java.lang.Class)
%   javax.lang.model.element.Element.getAnnotation(java.lang.Class)

\end{enumerate}

The arrays returned by the methods \code{getAnnotations(Class)},  
\code{getAnnotations()}, and \code{getDeclaredAnnotations()} are required
to preserve the ordering of the annotations as they were declared in the
original \code{.java} source file.

No other changes would be necessary.  Existing code that uses
some other workaround (like special \code{@AContainer} annotations) would
continue to work.  Or, it could be converted to take advantage of this new
mechanism.

The problem with this proposal is that it requires adding a single method,
\<getAnnotations>, to two interfaces.  While the changes would not break
upward binary-compatibility, they would break source-compatibility:
existing implementations of \<Element> and \<AnnotatedElement> could not
be re-compiled under Java 7 without adding a \<getAnnotations> method.
Sun's policy generally frowns upon such changes that break
source-compatibility, though they are sometimes made nonetheless.
% Such changes have to be approved by the CCC (conformance change committee).
For example, the
SQL interfaces have far more implementations than the compiler or
reflection APIs, but Java SE 6 added three methods to the
\<java.sql.Statement> interface and made it extend \<Wrapper>.
% This isn't even documented in the Java 6 Incompatibility Release notes
% (http://java.sun.com/javase/6/webnotes/compatibility.html#incompatibilities).

An alternative to changing the \<Element> (and \<AnnotatedElement>) interface is to create a new
\<Element2> interface that augments \<Element> with the \<getAnnotations>
method, and to mark \<Element> as deprecated.  Then, programmers should
rewrite their existing code to use the \<Element2> interface instead of the
\<Element> interface.  However, their code continues to compile until they
make the change.  A problem with this change is that it requires making a
copy (with names suffixed ``\<2>'') of the entire \<javax.lang.model>
package, which is ugly.

Another alternative is to change the \<Elements> utility interface.  The
new \<getAnnotations> methods logically belong in \<Element>, but they can
be added to the \<Elements> interface because it is explicitly documented
with ``Compatibility Note: Methods may be added to this interface in future
releases of the platform.''  Thus, adding static methods in \<Elements> is
a path toward extending functionality without changing core
interfaces/classes such as \<Element>.  A problem with this proposal is
that clients must remember to use the methods of \<Elements> when
functionality is not present in \<Element>.  A programmer browsing the
\<Element> interface might not think to check for static methods in
\<Elements>.


\subsubsection{JSR 175 design justification\label{duplicate-annotations-jsr175-justification}}

The JSR 175 Design FAQ~\cite{JSR175-PFD2} briefly addresses why this
feature was not originally included:

\begin{quote}
Why is it illegal [to] annotate a single element repeatedly with the same annotation type?

A similar effect is available by annotating once with an annotation type
whose sole element is of an array type. The resulting system is simpler and
cleaner: you don't have to worry about whether you're going to get back a
single instance of the annotation type or multiple instances when you query
an annotation. Also it's consistent with the usual restriction on
modifiers.
\end{quote}

The argument that ``the resulting system is simpler and cleaner'' is
perplexing.  A client must check for both the singular and plural versions
of the annotation and must handle the case when both the singular and the
plural versions are present.  By contrast to the stated claim, a system for
duplicate annotations with an interface that always returns a list (or
always returns an array) is what is needed to relieve the client of ``worry
about whether you're going to get back a single instance''.


\subsection{Locations for annotations\label{locations-for-annotations}}


\subsubsection{Annotations on receiver type parameters\label{receiver-type-parameter-annotations}}

It is sometimes desirable for a method to express constraints on the
generic parameters of the receiver, just as is already possible for other
formal parameters.  This is not currently possible (see the grammar of
Section~\ref{grammar-details}).

For example, consider the \<Collection.toArray()> method, which returns an
array of objects, where the objects have the same annotation as the
elements of the receiver.  A natural way to write this would be 

\begin{Verbatim}
  public @PolyNull Object[] toArray() Collection<@PolyNull E> { ... }
\end{Verbatim}

\noindent
except that this is illegal syntax:  ``\code{Collection<@PolyNull E>}'' in
the receiver position is not legal.  It is permissible to write an
annotation on the raw type of the receiver, as in

\begin{Verbatim}
  public Object[] toArray() @Readonly { ... }
\end{Verbatim}

\noindent
but not on the receiver's type parameters.

Here are other examples:

\begin{Verbatim}
  interface List<T> {
    // The size() method changes neither the receiver nor any of the elements.
    public int size() @Readonly List<@Readonly T> { ... }
  }
  class MyMap<T,U> {
    // The map's values must be non-null, but the keys may be arbitrary.
    public void requiresNonNullValues() MyMap<T, @NonNull U> { ... }
  }
\end{Verbatim}

An alternate, more concise syntax would write only the annotations, rather
than explicitly writing the receiver type.  Annotations on the generic type
parameters of the receiver are written within angle brackets.  The
annotation on the receiver type itself may be present or absent.  For
example:

\begin{Verbatim}
  interface Collection<E> {
    public @PolyNull Object[] toArray() <@PolyNull> { ... }
  }
  interface List<T> {
    // The size() method changes neither the receiver nor any of the elements.
    public int size() @Readonly<@Readonly> { ... }
  }
  class MyMap<T,U> {
    // The map's values must be non-null, but the keys may be arbitrary.
    public void requiresNonNullValues() <,@NonNull> { ... }
  }
\end{Verbatim}


\subsubsection{Annotations on statements\label{statement-annotations}}

Annotations on statements (or on some subset of statements, such as blocks
or loops) would be useful for a variety of purposes, including
atomicity/concurrency.  Supporting annotations on statements would require
defining both Java syntax and a convention for storing the information in
the class file.  See
\myurl{http://code.google.com/p/jsr308-langtools/wiki/AnnotationsOnStatements} for a
proposal that summarizes why statement annotations are desirable, and that
proposes a Java syntax, a classfile storage format, and how other tools
will accommodate them.  If you would like to help this feature become a
reality, then please pitch in!  You can join the
\code{jsr308-discuss@googlegroups.com} mailing list (via
\myurl{http://groups.google.com/group/jsr308-discuss}),
expand the partial design on the wiki, or work on the implementation.

The JSR 175 Design FAQ~\cite{JSR175-PFD2} briefly addresses why this
feature was not originally included:

\begin{quote}
  Why can't you annotate arbitrary program elements such as blocks
    and individual statements?

  This would greatly complicate the annotation syntax: We would have to
  sacrifice the simplicity of saying that annotations are simply modifiers,
  which can be used on declarations.
\end{quote}


\subsubsection{Expression annotations\label{expression-annotations}}

Annotating an expression
indicates some property of the computation, such as that it should
be performed atomically, that it acquires no locks, or that it should be
formatted specially by an IDE\@.  JSR 308 does not support expression
annotations, because we have not yet discovered compelling use cases for
them that cannot be equally well supported by statement annotations.  (A
minor inconvenience is that the use of statement annotations may require
the programmer to create a separate statement for the expression to be
annotated.)
Expression annotations are not type annotations and are different than
annotating a type cast, which indicates a property of a value (the result
of an expression).


\subsubsection{Implicit Java types in casts\label{implicit-java-types-in-casts}}

Arbitrary values can be annotated using an annotation on a cast:
\begin{Verbatim}
  (@Language("SQL") String) "select * from foo"
\end{Verbatim}

A possible shorthand would be to permit the Java type to be implicit:
\begin{Verbatim}
  (@Language("SQL")) "select * from foo"
\end{Verbatim}
This is not permitted, nor may a cast be omitted in a type test, as in
``\code{x instanceof @NonNull}''.  There are several reasons for this
decision:
\begin{enumerate}
\item Erasing the annotations should leave a valid Java program.
\item Stating the type reinforces that the annotation is a
type annotation rather than an expression annotation.
\item Especially in a type test, stating the type reinforces that the run-time
effect is to check and change the Java type.  In general, no run-time check
of the annotation is possible.
\item The benefit of omitting the type in the cast seems relatively minor.
\end{enumerate}

An even shorter shorthand would drop the parentheses:
\begin{Verbatim}
  @Language("SQL") "select * from foo"
\end{Verbatim}
In addition to the benefits and problems noted above, such an annotation is
syntactically ambiguous with an expression annotation.
Whether an annotation applies to expressions or to types is clear from the
annotation's documentation and its \code{@Target} meta-annotation,
similarly to how it is determined whether an annotation applies to a type
or to a declaration (Section~\ref{disambiguating}).

% But a problem remains.
% If a within-brackets proposal for arrays
% % (Section~\ref{array-syntax})
% is
% chosen, then \code{Object[@X 2]}
% might mean that the array level has annotation \code{X} or that it's shorthand
% for \code{Object[(@X int) 2]}; similar confusion might occur when the array
% length is a more complex expression.

% Possible problem: @Readonly means something different when applied to an
% expression and to a type, though perhaps a different name would be better
% for the expression.


%       One advantage of the expression version is that casts in general
%       shouldn't appear in code (and tools may raise warnings about them).
%       But the same is true of annotation casts!
%       Compilers shouldn't complain about redundant casts that are
%       annotated (but annotation processors should).


\subsubsection{Only certain statements\label{locations-subset-of-statements}}

It would be possible to permit annotations only on blocks and/or loops, as
a restricted special case of statements.  This is less general than
permitting annotations on statements, and uses are more syntactically
cluttered (for instance, this requires a statement to be converted into a
block before it can be annotated).  Most declarations could not be
annotated as statements because enclosing the declaration in a block to
annotate it would change (and limit) the variable's scope.  This limitation
in flexibility does yield the advantage that there would be no syntactic
ambiguity between (say) statement annotations and declaration or type
annotations.

Similarly, permitting annotations on partial constructs (such as only the
body of a loop) appears both more complex, and no more useful, than
annotating complete constructs (such as a full statement).


\subsection{Changes to the annotation type\label{changes-to-the-annotation-type}}


\subsubsection{Inheritance among annotations (subclassing/subtyping annotations)\label{inheritance-among-annotations}}

% \label{subclassing-annotations}\label{subtyping-annotations}

In Java SE 6, annotations cannot subclass one another, and an annotation is not allowed
to extend/implement any interfaces.  These restrictions make it difficult
to share behavior or to express similarities or relationships among
annotation types.  For example, it is inconvenient to define annotations
with choices in their structure, such as a discriminated union that uses
field names that act as explicit tags.  It is impossible to create
annotation processors or APIs that work with a specific set of annotations
(say, all those with a given set of element names).

Permitting inheritance among annotations would solve these problems.  (To
work around the problem, one could meta-annotate an annotation as a
``subannotation'' of another, and then the annotation processor could do
all the work to interpret the meta-annotation.  This is clumsy and
indirect.)

A potential objection is that multiple annotation processors might try to
claim the same annotation, one directly and one by claiming its supertype.
This can be accommodated.  In general, annotation processor designers
should, and can, avoid this situation by running one processor at a time
for a family of annotations that are related by inheritance.


%% This text is inaccurate; JLS 9.6 merely says that an member can have an
%% annotation type, and elsewhere inheritance among annotations is prohibited.
% Inheritance among annotations would slightly relax Java's current
% restriction on annotations as annotation members, namely that an annotation
% can have a member that is an annotation \emph{of a specific type}.

Without other changes, inheritance among annotations would not enable
recursive or self-referential annotations (see
Section~\ref{annotations-as-members}).

There are two general designs that permit inheritance among annotations:
permitting annotations to subclass other annotations, or permitting
annotations to extend/implement interfaces, or both.
We briefly elaborate on the two designs.

\paragraph{Subclassing annotations}

Permitting inheritance among annotations requires that the \code{final}
modifier on an annotation type declaration works just like for ordinary
classes:  it prevents creation of subtypes of the given annotation.  A
framework that defines annotation \code{@A} may not want to load an
untrusted subclass \code{@B} of \code{@A} into the framework.

The specification of the \code{getAnnotation(Class)} method must be
updated.  Suppose that annotation types \code{Sub1} and \code{Sub2} are
direct subtypes of \code{Super}, and \code{Super} has a \code{value} field
of type \code{int}.  The specification must indicate the behavior of
\code{getAnnotation(Super.class)} when called on locations with all
possible combinations of the three annotations, with all possible
combinations of arguments.  Here are a few examples:

\begin{itemize}
\item
 a location that is annotated with \code{@Sub1(1)} but not annotated with
 \code{@Super}
\item
 a location that is annotated with both \code{@Super(0)} and \code{@Sub1(1)}
\item
 a location that is annotated with both \code{@Sub1(0)} and
 \code{@Sub2(0)}, but not annotated with \code{@Super}
\item
 a location that is annotated with \code{@Sub1(1)} and \code{@Sub2(2)}, but
 not annotated with \code{@Super}
\end{itemize}

\noindent
Reflection APIs may also need to be updated.

As is clear from the examples above,
subclassing annotations raises the possibility of multiple effective
annotations applying at a location.
Therefore, subclassing annotations makes most sense if the specification
already permits duplicate annotations (see
Section~\ref{duplicate-annotations}).
In that case,
the new \code{getAnnotations(Class)} method returns all of the annotations.
(Then, the client can decide what to do with them, such as raise an
error, merge the annotations, or take some other action.)


The JSR 175 Design FAQ~\cite{JSR175-PFD2} briefly addresses why this
feature was not originally included:

\begin{quote}
Why don't you support annotation subtyping (where one annotation type
extends another)?

It complicates the annotation type system, and makes it much more difficult
to write ``Specific Tools''.

\ldots

``Specific Tools'' --- Programs that query known annotation types of
arbitrary external programs. Stub generators, for example, fall into this
category. These programs will read annotated classes without loading them
into the virtual machine, but will load annotation interfaces.
\end{quote}

% My best guess is that the "specific tools" would need to look not just
% for a specific annotation, but would have to check every annotation to
% see whether it's a subclass of the one the tool is written for.  And, the
% specific tool doesn't want to load untrusted annotations (or, for that
% matter, all annotations) just to check whether they are a subclass of the
% specific annotation.

% Support for the "final" modifier may answer much of this objection.


\paragraph{Extending/implementing interfaces}

%% Joe Darcy says:
% I would support allowing annotation type to extend interfaces, including
% when those interfaces happened to be annotation types, keeping the current
% restrictions on what methods can be declared in an annotation type.  There
% would be no deeper annotation subtyping relation between annotation types
% where one extended the other in terms of how they were processed, etc.


Permitting annotation types to extend/implement interfaces is less
powerful than subclassing among annotations.
For example, interfaces can't define default values, nor is it possible
to subclass an annotation to enhance functionality.
An advantage of this approach is that there is no possibility of multiple
annotations with a given supertype appearing at a location.

One use case is marker interfaces.
%
In another use case, the interface could define several elements/methods.
These could define a standard set of element names that are used by a set
of specific annotations.  APIs that use the interface could work with any
annotation from that set.

The currently permitted annotation member types (``primitive types, String,
Class and any invocation of Class, an enum type, an annotation type, or an
array of one of the preceding types''~\cite[\S9.6]{GoslingJSB2005}) should
be extended to include interfaces (or perhaps only interfaces that extend
\code{java.lang.annotation.Annotation}).


% Does this example belong here?
%   @Units(value={@Meters}, dividedBy={@Seconds}




\subsubsection{Potentially recursive annotations (annotations as members of annotations)\label{annotations-as-members}\label{annotations-as-arguments}\label{recursive-annotations}}

In Java, an annotation can have a parameter (equivalently, a member) that is an
annotation (JLS
\ahref{\jlsNineSixURL}{\S9.6} and
\ahref{\jlsNineSevenURL}{\S9.7}).
JLS
\ahref{\jlsNineSevenURL}{\S9.7}
gives this example:

\begin{Verbatim}
  @Author(@Name(first = "Joe", last = "Hacker"))
\end{Verbatim}

However, an annotation type cannot have a member of its own type.
``It is a compile-time error if an annotation type \emph{T} contains an
element of type \emph{T}, either directly or
indirectly''~\cite[\S9.6]{GoslingJSB2005}.
(If inheritance among annotations is permitted (see
Section~\ref{inheritance-among-annotations}), then the natural
interpretation of this is that no element's declared type may be either the
annotation itself or any supertype thereof.)

As a particular example, it is not possible to define an annotation that
takes an \emph{arbitrary} annotation as a parameter, as in

\begin{Verbatim}
  @DefaultAnnotation(@AnyAnnotation)
\end{Verbatim}

These limitations reduce the expressiveness of annotations.  Here are some
examples:
\begin{itemize}
\item
  It is impossible to define annotations that take an arbitrary annotation
  as an argument.

  Two examples of such annotations are the \code{@DefaultAnnotation}
  example above, and an annotation that expresses that a method is
  polymorphic over annotations (as opposed to polymorphic over types, as
  generics do).

  Another example is annotation parameters that do not correspond to a type
  parameter.  Consider a container class that is designed to hold things of
  a specific type (say, it interacts with the elements in domain-specific
  ways), not of an arbitrary type.  The container has no type parameter,
  but it may still make sense to have annotations on the contained thing.
  Most of the examples of generics and arrays from
  Section~\ref{generics-and-arrays} also serve as examples here.  The
  argument applies not just to container classes but also to algorithms
  that process data of a specific type.

  These examples require the annotation declaration to be potentially
  recursive.  However, they do not require that any recursive annotation
  ever be created in practice.  They could be achieved even if creation of
  recursive annotation instances was prohibited.

\item
  % Need examples here; Jonathan Aldrich volunteered to provide them.
  It is impossible to define annotations with recursive structure.

  More generally, the kind of data that can be encoded in annotations is
  limited.  It is generally possible to store data which has a fixed
  structure, but it is much more difficult to encode more complex data,
  including hierarchical data.  As the success of \ahref{http://www.w3.org/XML/}{XML}, \ahref{http://www.yaml.org/}{YAML}, and other such
  technologies has shown, the ability to encode structured data is very
  powerful for a wide variety of uses, many of which we cannot anticipate
  today.  Today's annotations only fulfill a small piece of that potential.

  To express the base case, recursive annotations also require either
  inheritance among annotations
  (Section~\ref{inheritance-among-annotations}), or nullable members
  (Section~\ref{nullable-members}), or a requirement that recursion takes
  place through an array (an empty array would terminate the recursion).

\end{itemize}

% - What about the behavior of existing code that reflects over annotation 
% types and expects never to see recursively-typed members?


A more modest approach that makes annotations somewhat more expressive
would be to permit inheritance among annotations (see
Section~\ref{inheritance-among-annotations}) without permitting possibly
self-referential annotations.


The JSR 175 Design FAQ~\cite{JSR175-PFD2} briefly addresses why this
feature was not originally included:

\begin{quote}
  Why is it illegal for an annotation type to contain an element of the same type?

At first glance it would appear that you could never annotate with such a type, so the prohibition might seem unnecessary, but you can get yourself into trouble if you also provide a default:

\begin{Verbatim}
@interface Foo {
    Foo foo() default @Foo;
}

@Foo int i;
\end{Verbatim}

If this were legal, the resulting annotation would be self-referential (or
infinite), as well as useless.
\end{quote}


\subsubsection{Null as an annotation field value (nullable fields)\label{nullable-members}}

Currently, it is possible to choose/create a special value and to store
that value in an annotation field.
The proposal would permit use of \code{null} instead of an explicit
user-specified value.

The proposal makes some programming idioms slightly shorter.  For example,
specifying the base case of a recursive data structure will require simply
writing \code{null} instead of calling a constructor.  The proposal does
not eliminate any substantial complexity when processing a data structure,
but only converts a check against a given value into a check against null.

We note some possible objections to the proposal.

The proposal doesn't make anything possible that was not possible before.

The programmer-defined special value provides better documentation than
\code{null}, which might mean ``none'', ``uninitialized'', \code{null}
itself, etc.

The proposal is more error-prone.  It's much easier to forget checking
against null than to forget checking for an explicit value.

The proposal may make the standard idiom more verbose.  Currently only the
users of an annotation need to check for its special values.  With the
proposal, many tools that process annotations will have to check whether a
field's value is null lest they throw a null pointer exception.


\subsubsection{Positional arguments\label{positional-arguments}}

Annotation types cannot have positional arguments (except for the
\code{value} argument, when it is the only argument).  This limitation
makes writing annotations with multiple arguments more verbose than
necessary.

% Suggestion from Bruce Chapman
On a somewhat related topic, the ``SingleElementAnnotation'' form relies on
the field name \code{value}.  This name is not always appropriate;
designers who wish to permit the ``SingleElementAnnotation'' form are
forced to give a member a confusing name.  It would be nice to permit the
``SingleElementAnnotation'' form to initialize a different member than
\code{value} (say, via a \code{@ValueMember} annotation).


\subsection{Semantics of annotations\label{semantics}}

\subsubsection{Annotations for specific purposes\label{no-defined-annotations}}

JSR 308 does not define any annotations.
%  nor take any position on their semantics.
JSR 308 extends the Java and class file syntax to permit
annotations to be written in more places, and thus makes existing and
future annotations more useful to programmers.

By contrast, JSR 305 ``Annotations for Software Defect Detection'' aims to
define a small set of annotations.
Examples include type annotations such as non-nullness
(\code{@Nonnull}), signedness (\code{@Nonnegative}), tainting, and string
format; and also declaration annotations such as whether a method's return
value should always be checked by the caller.
A programmer who cares about code quality will use both annotations
defined in the JSR 305 ``standard library'', and also others that are
defined by third parties or by the programmer himself.
For more details about JSR 305, see
\myurl{http://jcp.org/en/jsr/detail?id=305} and
\myurl{http://groups.google.com/group/jsr-305/}.
Since JSR 305 appears to be abandoned, this section is now primarily of
historical interest.

Any type annotation, including those defined by JSR 305, is of limited use
without the JSR 308 syntax.  Without the JSR 308 annotation syntax, a
static checker may lose track of type qualifiers whenever a program uses
generic types (e.g., collection classes), whenever a method is invoked on
an object, whenever a cast is performed, whenever a class is subclassed,
etc.  From the point of code checking, using the old Java annotation syntax
is even worse than the type unsoundness of pre-generics Java, when there
was no compiler-enforced type correctness guarantee for collections
classes.  Therefore, use of JSR 305 without JSR 308 is much less effective.

% As of fall 2008,
The JSR 305 team does not plan any reference implementation.
This hinders both programmers who want to use the annotations,
and also people trying to interpret the meaning of the specification.  By
contrast, the JSR 308 reference implementation and the Checker Framework
for compile-time type-checking have been available since January 2007.
The Checker Framework contains checkers for many of the most useful
annotations proposed in JSR 305.




% For
% instance, it is JSR 305's role to decide whether Java programmers will
% write \code{@NonNull} or \code{@Nonnull} or \code{@NotNull}, and what it
% means when they write it.


\subsubsection{Annotation inheritance\label{annotation-inheritance}}

(This section is \emph{not} about whether the definition of an annotation
may inherit from other classes/interfaces.  Rather, it is about whether a
class/interface inherits annotations from its superclasses/interfaces.)

The annotation type
\ahref{http://java.sun.com/javase/6/docs/api/java/lang/annotation/Inherited.html}{\code{java.lang.annotation.Inherited}}
(JLS \ahref{\jlsNineSixOneThreeURL}{\S9.6.1.3})
indicates that annotations on a class \code{C} corresponding to a given
annotation type are inherited by subclasses of \code{C}\@.  This implies
that annotations on interfaces are not inherited, nor are annotations on
members (methods, constructors, fields, etc.).

It might be useful to permit methods, fields, etc.\ to inherit annotations.

It might be useful to permit an annotation to be inherited from an
interface as well as from a superclass.

It might be useful to permit annotation inheritance to merge
information from the current and inherited annotations, instead of always
choosing the inherited one.

% These semantic issues are out of the scope of JSR 308 but may be
% taken up by JSR 305 (``Annotations for Software
% Defect Detection''~\cite{JSR305}).



% (An annotation
% processor can issue a warning if annotations are inconsistent between
% super- and sub-types.)

%   <li>A dynamic proxy class is a class (created by
%       <a href="http://java.sun.com/javase/6/docs/api/java/lang/reflect/Proxy.html"><code>java.lang.reflect.Proxy</code></a>) that is created at run time and
%       that implements a list of interfaces (that are also given at run
%       time).  What annotations should appear on the methods of the proxy
%       class?  Arguably, whichever annotations were on the methods of the
%       given interfaces (when a method appears more than once, whatever
%       annotations are on the method whose interface appears first in the
%       list, which takes precedence).
% 
%       But whether an annotation should be transferred to a proxy
%       class may depend on the annotation itself; should there be a way to
%       indicate how it should be treated?  This feels related to the issue
%       of inheritance and defaulting of annotations; perhaps any tool that
%       processes the annotations should also look up the annotations on the
%       interface(s) and use them, so it does not matter whether the
%       generated class itself has the annotations or not.
% 
%       How does Java handle this currently?  Do we believe the
%       current behavior is incorrect and needs to be amended in JSR 308?
%   </li>

\subsubsection{Default annotations\label{default-annotations}}

Specifying a default for annotations can reduce code size and (when used
carefully and sparingly) increase code readability.  For instance,
Figure~\ref{fig:example} uses \code{@DefaultQualifier("NonNull")} to avoid the clutter of 5
\code{@NonNull} annotations.  It would be nicer to have a general mechanism,
such as
\begin{Verbatim}
  @DefaultAnnotation(NonNull.class, locations={ElementType.LOCAL_VARIABLE})
\end{Verbatim}
Defaults for annotations are a semantic issue that is
out of the scope of JSR 308.  It will be taken up by JSR 305 (``Annotations
for Software Defect Detection''~\cite{JSR305}).

The defaulting syntax must also be able to specify the arguments to the
default annotation (in the above example, the arguments to \code{@NonNull}).

A better syntax would use an annotation, not a string or class literal, as the
argument to \code{@DefaultAnnotation}, as in
\begin{Verbatim}
  @DefaultAnnotation(@MyAnnotation(arg="foo"))
\end{Verbatim}
In Java, it is not possible to define an annotation that takes an
arbitrary annotation as a parameter; see
Section~\ref{annotations-as-arguments}.


An issue for JSR 260 (Javadoc) and JSR 305 (Annotation semantics) is how
inherited and defaulted annotations are handled in Javadoc:  whether they
are written out in full, or in some abbreviated form.  Just as too many
annotations may clutter source code, similar clutter-reduction ideas may
need to be applied to Javadoc.


\subsection{Type abbreviations and typedefs\label{typedef}}

An annotated type may be long and hard to read; compare \code{Map<String,
  Object>} to \code{@NonNull Map<@NonNull String, @NonNull Object>}.  Class
inheritance annotations and subclassing provides a partial solution, as
noted
%BEGIN LATEX
on page~\pageref{class-inheritance-annotations}
%END LATEX
in Section~\ref{class-inheritance-annotations} with the following example:

\begin{Verbatim}
  final class MyStringMap extends
    @Readonly Map<@NonNull String, @NonEmpty List<@NonNull @Readonly String>> {}
\end{Verbatim}

This approach limits reusability:  if a method is declared to take a
\code{MyStringMap} parameter, then a \code{Map} (even of the right type,
including annotations) cannot be passed to it.  (By contrast, a
\code{MyStringMap} can always be used where a \code{Map} of the appropriate
type is expected.)  Goetz~\cite{Goetz2006} recommends exploiting Java's
type inference to avoid some (but not all) instances of the long type name.

In summary, a built-in typedef mechanism might achieve both code
readability and reusability.


\subsection{Class file syntax\label{class-file-syntax}}

Changes to the class file syntax are out of the scope of JSR 308, which,
for backward compatibility, currently does not change the way that existing
annotations are stored in the class file.
Class file syntax changes require modification of
compilers, JVMs, javap, and other class file tools (see
Sections~\ref{class-file-tools} and~\ref{other-tools}).

% However, some changes to the class file syntax may have significant
% benefits.  


\subsubsection{Reducing class file size via use of the constant pool\label{constant-pool}}

Annotations could be stored in the constant pool, and use constant pool
references from the annotation points.  That would reduce class file size,
especially if an annotation is used in many places in the same class, as is
more likely once JSR 308 support is in place.
% with the annotations enabled by JSR 308 and those proposed in
% JSR 305.

\subsubsection{Optional/default fields in annotations\label{optional-default-fields}}

In order to reduce the size of the class file, some fields may be omitted
from the .class file, in which case any access of them returns their
default value.


\subsection{Access to method bodies in annotation processing API\label{out-of-scope-annotation-processing-api}}

A type-checking compiler plug-in (annotation processor) must process
annotations (including those in method bodies), and it also must check
each use of a variable/method whose declared type is annotated.  For
example, if a variable \code{x} is declared as \code{@NonNull Object x;},
then every assignment to \code{x} must be checked, because any assignment
\code{x = null;} would be illegal.

The JSR 269 annotation processing API
% specifies that the \code{process}
% method is invoked on class, field, and method annotations.  It
does not
process annotations on local variables, as it is not designed to access
method bodies.  This limitation makes JSR 269 insufficient for creating a
type-checking compiler plug-in.

An annotation and source code processing API for JSR 308 annotations could
take advantage of JSR 198's Java Model.  The Java Model defines a parsed
view into the contents of a source file that is intended for construction
of IDE extensions that are portable across multiple IDEs --- precisely the
situation with compiler plug-ins.  JSR 308 may be shipped without defining
this API, but defining this API may be desirable in the future (say, in a
later version of Java), particularly after more experience is gained with
type annotation processors.

In the absence of such an API, a type checker can be written using
compiler-specific APIs.  This is how the Checker Framework
(\myurl{http://types.cs.washington.edu/checker-framework/}) works.


\section{Logistical matters\label{logistics}}

JSR 308 (``Type annotations'') should be included under the Java SE 7
umbrella JSR (which lists the JSRs that are part of the Java SE 7 release).
However, it should be a separate JSR because it needs a separate expert group.
The expert group will have overlap with any others dealing with other
added language features that might be annotatable (such as method-reference
types or closures), to check impact.

The specification, reference implementation, and tests developed by the
JSR 308 community are freely available, with no restrictions on use.  As of
build M4 (see \url{http://openjdk.java.net/projects/jdk7/milestones/}), the
reference implementation has been incorporated into Sun's OpenJDK Java
implementation.  Sun will integrate the specification into the JLS (without
any conceptual changes or new information), will write additional tests,
etc.  We do not have control over the license terms that Sun places on its
changes.

To ease the transition from standard Java SE 6 code to code with the extended
annotations, the reference implementation recognizes the extended
annotations when surrounded by comment markers:
\begin{Verbatim}
  List</*@Readonly*/ Object> myList;
\end{Verbatim}
This permits use of both standard Java SE 6 tools and the new annotations even
before Java SE 7 is released.  However, it is not part of the proposal;
that is, it is not required that every Java compiler parses comments.
Sun's OpenJDK implementation does not support a switch that
makes it recognize the new annotations when embedded in comments.
The Spec\#~\cite{BarnettLS2004} extension to C\# can be made compilable by
a standard C\# compiler in a similar way, by enclosing its annotations in
special \verb|/*^|\ldots\verb|^*/| comment markers.
The \code{/*@} comment syntax is a standard part of the
Splint~\cite{Evans96}, ESC/Java~\cite{FlanaganLLNSS02}, and
JML~\cite{LeavensBR2006:JML} tools (that is, not
with the goal of backward compatibility).
% Javadoc has /**@ comments.


\subsection{Edits to existing standards documents\label{edits-to-standards}}

Edits to the Java Language Specification (JLS):
      We need a document, complementary to the design document, that lists
      every edit that is required in the JLS.
      A preliminary step would be a list of all the locations that must be
      edited (for instance, by searching the entire JLS for uses of
      ``annotation'', but the list will be a superset of the list of
      locations that were edited for
      JSR 175).
      The most important locations are the following.
\begin{itemize}
\item
Changes to sections 9.6 and 9.7
\item
Merge the BNF description of the Java syntax changes
(Sections~\ref{grammar-summary} and~\ref{grammar-details})
into \ahref{http://java.sun.com/docs/books/jls/third_edition/html/syntax.html}{JLS
          chapter 18: Syntax}.
\end{itemize}

Edits to the Java Virtual Machine Specification (JVMS)~\cite{LindholmY99,LindholmY99:CFF5}:
      We need a document, complementary to the design document, that lists
      every edit that is required in the JVMS\@.
      The most important of these is the following:
\begin{itemize}
\item
        Sections 4.8.15-18 define the \RuntimeInOrVisibleAnnotationsOrParameterAnnotations
        attributes.  (See
        \ahrefurl{\url{http://java.sun.com/docs/books/jvms/second_edition/ClassFileFormat-Java5.pdf}}
        for the JDK 1.5 revisions to chapter 4, ``The class file Format''.)
        Similar definitions are required for \RuntimeInOrVisibleTypeAnnotations.
\end{itemize}



\subsection{Testing (TCK, Technology Compatibility Kit)\label{testing}}

JSR 308 will ship with a test suite (known as a TCK, or Technology
Compatibility Kit).

Each tool that needs to be tested appears in Section~\ref{mods};
the TCK will include tests for each of them.

For each modified tool, we will test backward compatibility by passing all
of its existing tests.  (We may need to modify a few of them, for instance
those that depend on specific bytecodes that are created by the compiler.)

We will test most other functionality by creating a set of Java programs
that include annotations in every possible location.  For instance, this
can be used to test all aspects of the compiler (parsing, code generation,
\code{-Xprint}).


We will provide multiple annotation processors (including at least one for
checking \code{@NonNull} and one for checking \code{@Interned}) that
utilize the new annotations, along with a test suite for each one.  Each
annotation processor's test suite consists of annotated code, along with
expected output from the given annotation processor.  Since the annotation
processors utilize all aspects of JSR 308, this serves as an additional
end-to-end test of the JSR 308 implementation.  As a side benefit, the
annotation processors will be useful in their own right, will thereby
illustrate the utility of JSR 308, and will serve as examples for people
who wish to create their own type-checking plug-ins.



\subsection{Process\label{process}}

JSR 308 follows an unusually  open and transparent process.  Any interested
party may participate, decisions are made by consensus
to the greatest extent possible, and discussions
are publicly archived.  The Java Community Process requires that an
expert group formally approve the JSR at
% <a href="http://jcp.org/en/procedures/jcp2">
each stage.  The expert group members will only decide issues on which the
group cannot obtain consensus.

When posting, please act
professionally and courteously.  For example, your arguments should be
technical, specific, and based on logic; do not rely on your status or past
accomplishments to convince others, and give specific examples rather
than vague descriptions.  As another example, it is perfectly acceptable to
criticize a technical proposal, but do not make personal attacks.
Obviously, you should read the specification
and, preferably, try the implementation before posting to the mailing list.


\section{Related work\label{related-work}}

Section~\ref{type-qualifier-examples} gave many examples of how type
qualifiers have been used in the past.  Also see the related work section
of~\cite{PapiACPE2008}.

C\#'s attributes~\cite[chap.~24]{ECMA334-4th} play the same role as Java's
annotations:  they attach metadata to specific parts of a program, and are
carried through to the compiled bytecode representation, where they can be
accessed via reflection.  The syntax is different:  C\# uses
\code{[AnnotationName]} or \code{[AnnotationName:  data]} where Java uses
\code{@AnnotationName} or
\code{@AnnotationName(data)}; C\# uses \code{AttributeUsageAttribute} where
Java uses \code{Target}; and so forth.
However, C\# permits metadata
on generic arguments, and C\# permits multiple metadata instances of the
same type to appear at a given location.


Like Java, C\# does not permit
metadata on elements within a method body.
(The ``[a]C\#'' language~\cite{CazzolaCC2005:JOT}, whose name is pronounced
``annotated C sharp'', is an extension to C\# that permits annotation of
statements and code blocks.)

Harmon and Klefstad~\cite{HarmonK2007} propose a standard for worst-case
execution time annotations.


Pechtchanski's dissertation~\cite{Pechtchanski2003} uses annotations in the
aid of dynamic program optimization.  Pechtchanski implemented an extension
to the Jikes compiler that supports stylized comments, and uses these
annotations on classes, fields, methods, formals, local variable
declarations, object creation (\code{new}) expressions, method invocations
(calls), and program points (empty statements).  The annotations are
propagated by the compiler to the class file.


Mathias Ricken's LAPT-javac
(\myurl{http://www.cs.rice.edu/~mgricken/research/laptjavac/}) is a version
of javac (version 1.5.0\_06) that
encodes annotations on local variables in the class file, in new
\code{Runtime\-\{Inv},\code{V\}isible\-Local\-Variable\-Annotations} attributes.
The class file format of LAPT-javac differs from that proposed in this
document.
Ricken's xajavac (Extended Annotation Enabled
javac) permits subtyping of annotations (\myurl{http://www.cs.rice.edu/~mgricken/research/xajavac/}).


The Java Modeling Language, JML~\cite{LeavensBR2006:JML}, is a behavioral
modeling language for writing specifications for Java code.  It uses
stylized comments as annotations, some of which apply to types.


Ownership types~\cite{ClarkePN98,Boyapati2004:PhD,Clark2001,ClarkD2002,PotaninNCB2006,NobleVP98,DietlM2005,LeinoM2004,YuP2006}
permit programmers to control aliasing and access among objects.  Ownership
types can be expressed with type annotations
% with type qualifiers??
and have been applied to program
verification~\cite{LeinoM2004,Muller2002,MullerPHL2006}, thread
synchronization~\cite{BoyapatiLR2002,JacobsPLS2005}, memory
management~\cite{AndreaCGNVZ2006,BoyapatiSBR2003}, and representation
independence~\cite{BanerjeeN2002}.


JavaCOP~\cite{AndreaeNMM2006} is a framework for implementing pluggable
type systems in Java.  Whereas JSR 308 uses standard
interfaces such as the Tree API and the JSR 269 annotation processing
framework, JavaCOP defines its own incompatible variants.
A JavaCOP type checker must be programmed in a combination of Java and
JavaCOP's own declarative pattern-matching and rule-based language.
JavaCOP's authors have defined parts of over a dozen
type-checkers in their language.  Their paper does not report that they have
run any of these type-checkers on a real program; this is due to
limitations that make JavaCOP impractical (so far) for real use.


JACK makes annotations on array brackets refer to the array, not the
elements of the array~\cite{MalePPD2008}.
% "Java bytecode verification for @NonNull types" says:
% @NonNull Integer @NonNull [] a1;
% When annotating arrays, the leftmost annotation associates with the element
% type, whilst that just before the braces associates with the array
% reference type.


\section*{Acknowledgments}

Matt Papi and Mahmood Ali designed and implemented the JSR 308 compiler as
modifications to Sun's OpenJDK javac compiler, and contributed to the JSR
308 design.

The members of the JSR 308 mailing list
(\myurl{http://groups.google.com/group/jsr308-discuss}) provided
valuable comments and suggestions.
%% This was accurate as of the end of 2006.
%% I have not kept track of additional feedback.
% We thank
% %
%  Joshua Bloch,
%  Gilad Bracha,
%  Alex Buckley,
%  Wayne Carr,
%  Bruce Chapman,
%  Joe Darcy,
%  Jeff Foster,
%  Neal Gafter,
%  David Greenfieldboyce,
%  Evan Ireland,
%  Sacha Labourey,
%  Doug Lea,
%  Todd Millstein,
%  R. Matthew McCutchen,
%  Ted Neward,
%  Jens Palsberg,
%  Bill Pugh,
%  Jaime Quinonez,
%  Matthew Tschantz,
% and
%  Eugene Vigdorchik
% %
% for their comments and suggestions.
%
Additional feedback is welcome.

% http://jcp.org/en/press/news/2007award_winners
JSR 308 received
the Most Innovative Java SE/EE JSR of the Year award in 2007,
at the 5th annual JCP Program Awards.
% http://jcp.org/en/press/news/2008JavaOnePR
JSR 308's spec leads (Michael
Ernst and Alex Buckley) were nominated as Most Outstanding Spec Lead for
Java SE/EE in 2008, at the 6th annual JCP Program Awards.
% http://java.sun.com/javaone/2009/rockstars.jsp
Michael Ernst won a Java Rock Star award for a presentation on the Checker
Framework, which builds on the Type Annotations syntax, at JavaOne 2009.





\bibliographystyle{alpha}
\bibliography{bibstring-unabbrev,types,ernst,invariants,generals,alias,concurrency}

\end{document}

% LocalWords:  fontsize pt NonNull getNeighbors const Readonly NonNullDefault
% LocalWords:  VM toolchain visibleTypeAnnotations JLS checkcast ops op pc anno
% LocalWords:  LocalVariableTable AbstractProcessor Messager premain javac YY
% LocalWords:  YYYY localizable unaliased typestate readwrite mpapi annotatable
% LocalWords:  ASM Bracha instanceof java Jens Palsberg multibyte UTF JIT un ta
% LocalWords:  getAnnotations getParameterAnnotations getReceiverAnnotation TCK
% LocalWords:  NonEmpty getReceiverAnnotations Neward Quinonez tion param JSRs
% LocalWords:  visibleParameterAnnotations sourced Sacha Labourey Vigdorchik lt
% LocalWords:  unibyte MyStringMap Hevea commandchars DIV gt edgesNonNull useE
% LocalWords:  InternedAnnotation LinkedList eNonNull objectequality JavaBean
% LocalWords:  WebSphere wildcards rodocs roarray util TraceClassVisitor Xprint
% LocalWords:  metadata AnnotationName AttributeUsageAttribute Pechtchanski's
% LocalWords:  Pechtchanski getSize Javac's ElementType NonNegative TODO javap
% LocalWords:  PrintStream println sec Klefstad int Ricken's LAPT TypeParameter
% LocalWords:  Inv isibleLocalVariableAnnotations JCP doclet javadoc JBuilder
% LocalWords:  jEdit NetBeans javacc BCEL nonobvious li href isibleType EE arr
% LocalWords:  SuppressWarnings dArray Kuleshov ClassFileFormat pdf num Dietl
% LocalWords:  DefaultAnnotation strictfp saveenumi ReadOnly ArrayAnnots roa
% LocalWords:  ArrayAnnot MyAnnotation ReadonlyDims Vitek LNCS Potanin myString
% LocalWords:  myObject GuardedBy accessLock Goetz JavaCOP signedness Nonnull
% LocalWords:  NotNull JavaCOP's TypeArguments BasicType ForVarControl nullness
% LocalWords:  FormalParameterDecls ForVarControlRest FormalParameterDeclsRest
% LocalWords:  FormalParameters VoidMethodDeclaratorRest MethodBody BracketsOpt
% LocalWords:  QualifiedIdentifierList MethodDeclaratorRest IdentifierSuffix
% LocalWords:  InterfaceMethodDeclaratorRest VoidInterfaceMethodDeclaratorRest
% LocalWords:  ConstructorDeclaratorRest VariableDeclaratorRest nonnullelements
% LocalWords:  VariableInitializer ConstantDeclaratorRest VariableDeclaratorId
% LocalWords:  UnannType MethodOrFieldDecl Unann MethodOrFieldRest langtools
% LocalWords:  InterfaceMethodOrFieldDecl InterfaceMethodOrFieldRest realtime
% LocalWords:  FindBugs CheckForNull Nullable desugar classfile var Alast BNF
% LocalWords:  isibleTypeAnnotations isible Papi's varargs Afirst ELTS toolset
% LocalWords:  MultipleAnnotations subannotation Subannotations MyFile enum pre
% LocalWords:  ThreadSafe Aldrich AContainer Javadocs bytecode JVMs bytecodes
% LocalWords:  wildcard superinterface supertype API readonly XML AOP Foo JML
% LocalWords:  JML's AtomicReferenceFieldUpdater atomicity Gafter Subclassing
% LocalWords:  subclassing subtyping OpenJDK Jikes xajavac Papi Gilad Millstein
% LocalWords:  Greenfieldboyce McCutchen Tschantz webpage IGJ ESC filesToSearch
% LocalWords:  DefaultQualifier grep nullable MyRepeatedAnnotationContainer lst
% LocalWords:  AnnotatedElement getRepeatedAnnotation annotationClass ASTNode
% LocalWords:  OuterClass InnerClass ReadonlyReceiver lastAccessedTime astStack
% LocalWords:  getReturnAnnotation getReturnAnnotations getAnnotation enums ldc
% LocalWords:  SingleElementAnnotation ValueMember AstStackIncrement dividedBy
% LocalWords:  expressionStack ExpressionStackIncrement genericsStack YAML wiki
% LocalWords:  GenericsStackIncrement identifierStack getDeclaredAnnotations
% LocalWords:  ReceiverNonNull superclasses TypeArgument runtime newMap ernst
% LocalWords:  Nonnegative typedefs unabbrev reusability typedef getstatic init
% LocalWords:  QualifiedIdentifier toArray localvar methodparam typeparam
% LocalWords:  typearg ClassFile clinit StackMapTable
